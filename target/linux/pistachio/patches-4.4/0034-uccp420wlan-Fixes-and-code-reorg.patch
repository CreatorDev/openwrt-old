From 2bf6af1ed3477cc93fca1451d34945aaf224b2c2 Mon Sep 17 00:00:00 2001
From: Sridhar Nuvusetty <Sridhar.Nuvusetty@imgtec.com>
Date: Thu, 6 Aug 2015 19:05:38 +0530
Subject: uccp420wlan: Fixes and code reorg

This commit has the following changes:

1. Got rid of the UNIFORM_BW_SHARING and CONFIG_MULTI_CHAN_DEBUG compile time
   flags
2. Fixed a kernel crash as listed in Bug #6227
3. Made buf_pool_bmp handling uniform across the code.
4. Send beacons to FW irrespective of current channel context and use only reserved tokens.
5. Event time stamp adjustment
6. Fixed old Production Test mode and added center_channel variable in /proc/params
7. Added flush_queues op
8. Fixed a connectivity issue with WEP shared key.
       Authentication used to timeout when security mode was configured as
       WEP-Shared Key. This has been currently resolved by advertising
       IEEE80211_HW_REPORTS_TX_ACK_STATUS to
       mac80211(which effectively increases the authentication timeout to 500ms).
9. Increased AP peer limit to 14.
        Previously this used to be 2. Each peer entry takes up some memory in the
        RPU and currently Danube can support upto 14 AP peers (considering an
        additional entry for STA interface peer).

Change-Id: Ia5f7c3558996ef55dfda57d4684a0e87622288a2
Signed-off-by: Sridhar Nuvusetty <Sridhar.Nuvusetty@imgtec.com>
---
 drivers/net/wireless/uccp420wlan/Makefile          |   3 +-
 drivers/net/wireless/uccp420wlan/inc/core.h        |  57 +-
 .../net/wireless/uccp420wlan/inc/host_umac_if.h    |  37 +-
 drivers/net/wireless/uccp420wlan/inc/umac_if.h     |  13 +-
 drivers/net/wireless/uccp420wlan/inc/version.h     |   2 +-
 drivers/net/wireless/uccp420wlan/src/80211_if.c    | 341 ++++++------
 drivers/net/wireless/uccp420wlan/src/core.c        | 109 ++--
 .../net/wireless/uccp420wlan/src/hal_hostport.c    |   6 +-
 drivers/net/wireless/uccp420wlan/src/tx.c          | 615 ++++++++++++++-------
 drivers/net/wireless/uccp420wlan/src/umac_if.c     | 162 +++++-
 10 files changed, 873 insertions(+), 472 deletions(-)

diff --git a/drivers/net/wireless/uccp420wlan/Makefile b/drivers/net/wireless/uccp420wlan/Makefile
index 15c4429..d9d0c16 100644
--- a/drivers/net/wireless/uccp420wlan/Makefile
+++ b/drivers/net/wireless/uccp420wlan/Makefile
@@ -1,7 +1,6 @@
 uccp420wlan-objs		:= src/80211_if.o src/core.o src/umac_if.o src/tx.o src/hal_hostport.o src/fwldr.o
-ccflags-y += -DUNIFORM_BW_SHARING
 ccflags-y += -DMULTI_CHAN_SUPPORT
-ccflags-y += -DCONFIG_MULTI_CHAN_DEBUG
 obj-$(CONFIG_UCCP420WLAN)	+= uccp420wlan.o
 ccflags-y += -I$(src)/inc
 
+
diff --git a/drivers/net/wireless/uccp420wlan/inc/core.h b/drivers/net/wireless/uccp420wlan/inc/core.h
index 64ff73f..abb9fa3 100644
--- a/drivers/net/wireless/uccp420wlan/inc/core.h
+++ b/drivers/net/wireless/uccp420wlan/inc/core.h
@@ -68,11 +68,6 @@ extern spinlock_t tsf_lock;
 #define DEBUG_LOG(...) do { } while (0)
 #endif
 
-#ifdef CONFIG_MULTI_CHAN_DEBUG
-#define MULTI_CHAN_DEBUG(fmt, args...) pr_debug(fmt, ##args)
-#else
-#define MULTI_CHAN_DEBUG(...) do { } while (0)
-#endif
 
 #define MAX_OUTSTANDING_CTRL_REQ 2
 #define RESET_TIMEOUT 5000   /* In milli-seconds*/
@@ -81,6 +76,9 @@ extern spinlock_t tsf_lock;
 #define CH_PROG_TIMEOUT 500   /* In milli-seconds*/
 #define CH_PROG_TIMEOUT_TICKS msecs_to_jiffies(CH_PROG_TIMEOUT)
 
+#define QUEUE_FLUSH_TIMEOUT  2000   /* Specify delay in milli-seconds*/
+#define QUEUE_FLUSH_TIMEOUT_TICKS   msecs_to_jiffies(QUEUE_FLUSH_TIMEOUT)
+
 #ifdef CONFIG_PM
 #define PS_ECON_CFG_TIMEOUT 1000
 #define PS_ECON_CFG_TIMEOUT_TICKS msecs_to_jiffies(PS_ECON_CFG_TIMEOUT)
@@ -113,6 +111,10 @@ extern spinlock_t tsf_lock;
 #define TICK_NUMRATOR 12288 /* 12288 KHz  */
 #define TICK_DENOMINATOR 1000 /* 1000 KHz */
 
+#define BTS_AP_24GHZ_ETS 195 /* Microsecs */
+#define BTS_AP_5GHZ_ETS 25 /* Microsecs */
+
+
 enum noa_triggers {
 	FROM_TX = 0,
 	FROM_TX_DONE,
@@ -386,6 +388,11 @@ struct tx_pkt_info {
 	struct sk_buff_head pkt;
 	unsigned int hdr_len;
 	unsigned int queue;
+	unsigned int rate[4];
+	unsigned int retries[4];
+	unsigned int curr_retries;
+	unsigned int max_retries;
+	bool adjusted_rates;
 };
 
 
@@ -403,7 +410,6 @@ struct tx_config {
 	unsigned int next_spare_token_ac;
 
 	/* Used to store the address of pending skbs per ac */
-#ifdef UNIFORM_BW_SHARING
 	struct sk_buff_head pending_pkt[MAX_PEND_Q_PER_AC][NUM_ACS];
 
 #ifdef MULTI_CHAN_SUPPORT
@@ -412,9 +418,6 @@ struct tx_config {
 #else
 	unsigned int curr_peer_opp[NUM_ACS];
 #endif
-#else
-	struct sk_buff_head pending_pkt[NUM_ACS];
-#endif
 
 	/* Used to store the address of tx'ed skb and len of 802.11 hdr
 	 * it will be used in tx complete.
@@ -459,11 +462,11 @@ struct econ_ps_cfg_status {
 #endif
 
 struct current_channel {
-	unsigned int pri_chnl_num;
-	unsigned int chnl_num1;
-	unsigned int chnl_num2;
+	unsigned int center_freq1;
+	unsigned int center_freq2;
 	unsigned int freq_band;
 	unsigned int ch_width;
+	unsigned int pri_chnl_num;
 };
 
 struct roc_params {
@@ -507,9 +510,7 @@ struct mac80211_dev {
 			 * STA mode is active
 			 */
 	struct ieee80211_vif *vifs[MAX_VIFS];
-#ifdef UNIFORM_BW_SHARING
 	struct ieee80211_sta *peers[MAX_PEERS];
-#endif
 	struct ieee80211_hw *hw;
 	struct sta_tid_info  tid_info[32];
 	spinlock_t bcast_lock; /* Used to ensure more_frames bit is set properly
@@ -566,14 +567,13 @@ struct umac_vif {
 #endif
 };
 
-#ifdef UNIFORM_BW_SHARING
 struct umac_sta {
 	int index;
+	int vif_index;
 #ifdef MULTI_CHAN_SUPPORT
 	struct umac_chanctx *chanctx;
 #endif
 };
-#endif
 
 #ifdef MULTI_CHAN_SUPPORT
 struct umac_chanctx {
@@ -605,12 +605,21 @@ extern void uccp420wlan_vif_set_edca_params(unsigned short queue,
 extern void uccp420wlan_vif_bss_info_changed(struct umac_vif *uvif,
 					     struct ieee80211_bss_conf
 					     *bss_conf, unsigned int changed);
-extern int  uccp420wlan_tx_frame(struct sk_buff *skb, struct ieee80211_sta *sta,
-				 struct mac80211_dev *dev, bool bcast);
+extern int  uccp420wlan_tx_frame(struct sk_buff *skb,
+				 struct ieee80211_sta *sta,
+				 struct mac80211_dev *dev,
+#ifdef MULTI_CHAN_SUPPORT
+				 int curr_chanctx_idx,
+#endif
+				 bool bcast);
 extern int __uccp420wlan_tx_frame(struct mac80211_dev *dev,
 				  unsigned int queue,
 				  unsigned int token_id,
-				  unsigned int more_frames);
+#ifdef MULTI_CHAN_SUPPORT
+				  int curr_chanctx_idx,
+#endif
+				  unsigned int more_frames,
+				  bool retry);
 extern void uccp420wlan_tx_init(struct mac80211_dev *dev);
 extern void uccp420wlan_tx_deinit(struct mac80211_dev *dev);
 
@@ -620,14 +629,16 @@ extern int wait_for_reset_complete(struct mac80211_dev *dev);
 
 extern void uccp420wlan_tx_proc_pend_frms(struct mac80211_dev *dev,
 				   int queue,
-#ifdef UNIFORM_BW_SHARING
-				   int peer_id,
+#ifdef MULTI_CHAN_SUPPORT
+				   int curr_chanctx_idx,
 #endif
+				   int peer_id,
 				   int token_id);
-#ifdef UNIFORM_BW_SHARING
 int get_curr_peer_opp(struct mac80211_dev *dev,
-		      int queue);
+#ifdef MULTI_CHAN_SUPPORT
+		      int curr_chanctx_idx,
 #endif
+		      int queue);
 
 /* Beacon TimeStamp */
 __s32 __attribute__((weak)) frc_to_atu(__u32 frccnt, __u64 *patu, s32 dir);
diff --git a/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h b/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
index 1320e01..5d41ad9 100644
--- a/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
+++ b/drivers/net/wireless/uccp420wlan/inc/host_umac_if.h
@@ -33,16 +33,15 @@
 #define MAX_KEY_LEN 16
 #define MAX_VIFS 2
 
-#ifdef UNIFORM_BW_SHARING
-#define MAX_PEERS 3
+#define MAX_PEERS 15
 /* Additional queue for unicast frames directed to non-associated peers (for
- * e.g. Probe Responses etc) */
+ * e.g. Probe Responses etc)
+ */
 #define MAX_PEND_Q_PER_AC (MAX_PEERS + MAX_VIFS)
 
 #ifdef MULTI_CHAN_SUPPORT
 #define MAX_CHANCTX 2
 #endif
-#endif
 
 #define WEP40_KEYLEN 5
 #define WEP104_KEYLEN 13
@@ -96,6 +95,20 @@ enum UMAC_QUEUE_NUM {
 	WLAN_AC_MAX_CNT
 };
 
+
+enum UMAC_EVENT_ROC_STAT {
+	UMAC_ROC_STAT_STARTED,
+	UMAC_ROC_STAT_STOPPED,
+	UMAC_ROC_STAT_DONE,
+	UMAC_ROC_STAT_ABORTED
+};
+
+enum UMAC_VIF_CHANCTX_TYPE {
+	UMAC_VIF_CHANCTX_TYPE_OPER,
+	UMAC_VIF_CHANCTX_TYPE_OFF,
+	MAX_UMAC_VIF_CHANCTX_TYPES
+};
+
 struct umac_event_tx_done {
 	struct host_mac_msg_hdr hdr;
 
@@ -115,6 +128,7 @@ struct umac_event_tx_done {
 #ifdef MULTI_CHAN_SUPPORT
 #define TX_DONE_STAT_DISCARD_CHSW (6)
 #endif
+#define TX_DONE_STAT_DISCARD_OP_TX (7)
 	unsigned char frm_status[MAX_TX_CMDS];
 	unsigned char retries_num[MAX_TX_CMDS];
 	/* rate = Units of 500 Kbps or mcs index = 0 to 7*/
@@ -328,6 +342,12 @@ enum UMAC_PS_ECON_WAKE_TRIG {
 	TRIG_DISCONNECT
 };
 
+struct umac_event_roc_status {
+	struct host_mac_msg_hdr hdr;
+	unsigned int roc_status;
+} __packed;
+
+
 struct umac_event_ps_econ_wake {
 	struct host_mac_msg_hdr hdr;
 	enum UMAC_PS_ECON_WAKE_TRIG trigger;
@@ -410,6 +430,7 @@ enum UMAC_EVENT_TAG {
 	UMAC_EVENT_RF_CALIB_DATA,
 	UMAC_EVENT_RADAR_DETECTED,
 	UMAC_EVENT_MSRMNT_COMPLETE,
+	UMAC_EVENT_ROC_STATUS,
 #ifdef MULTI_CHAN_SUPPORT
 	UMAC_EVENT_CHAN_SWITCH,
 #endif
@@ -425,6 +446,9 @@ enum CONNECT_RESULT_TAG {
 	CONNECT_START_IBSS
 };
 
+enum UMAC_TX_FLAGS {
+	UMAC_TX_FLAG_OFFCHAN_FRM
+};
 
 /* Commands */
 struct cmd_tx_ctrl {
@@ -450,6 +474,9 @@ struct cmd_tx_ctrl {
 	 */
 	unsigned int force_tx;
 
+	/* Flags to communicate special cases regarding the frame to the FW */
+	unsigned int tx_flags;
+
 	unsigned char num_rates;
 
 #define USE_PROTECTION_NONE 0
@@ -679,7 +706,7 @@ struct cmd_roc {
 	struct host_mac_msg_hdr hdr;
 #define ROC_STOP 0
 #define ROC_START 1
-	unsigned int roc_status;
+	unsigned int roc_ctrl;
 	unsigned int roc_channel;
 	unsigned int roc_duration;
 
diff --git a/drivers/net/wireless/uccp420wlan/inc/umac_if.h b/drivers/net/wireless/uccp420wlan/inc/umac_if.h
index 834ed47..cd6ba74 100644
--- a/drivers/net/wireless/uccp420wlan/inc/umac_if.h
+++ b/drivers/net/wireless/uccp420wlan/inc/umac_if.h
@@ -83,7 +83,11 @@ extern int uccp420wlan_proc_tx(void);
 
 extern int uccp420wlan_prog_tx(unsigned int queue,
 			       unsigned int more_data,
-			       unsigned int tokenid);
+#ifdef MULTI_CHAN_SUPPORT
+			       int curr_chanctx_idx,
+#endif
+			       unsigned int tokenid,
+			       bool retry);
 
 extern int uccp420wlan_sta_add(int index,
 			       struct peer_sta_info *sta);
@@ -190,8 +194,8 @@ extern int uccp420wlan_prog_txq_params(int index,
 				       unsigned int uapsd);
 
 extern int uccp420wlan_prog_channel(unsigned int prim_ch,
-				    unsigned int ch_no1,
-				    unsigned int ch_no2,
+				    unsigned int center_freq1,
+				    unsigned int center_freq2,
 				    unsigned int ch_width,
 #ifdef MULTI_CHAN_SUPPORT
 				    unsigned int vif_index,
@@ -254,6 +258,9 @@ extern void uccp420wlan_proc_tx_complete(struct umac_event_tx_done *txdone,
 				    void *context);
 
 extern void uccp420wlan_tx_complete(struct umac_event_tx_done *txdone,
+#ifdef MULTI_CHAN_SUPPORT
+				    int curr_chanctx_idx,
+#endif
 				    void *context);
 
 extern void uccp420wlan_rx_frame(struct sk_buff *skb,
diff --git a/drivers/net/wireless/uccp420wlan/inc/version.h b/drivers/net/wireless/uccp420wlan/inc/version.h
index e1fa311..c2a476c 100644
--- a/drivers/net/wireless/uccp420wlan/inc/version.h
+++ b/drivers/net/wireless/uccp420wlan/inc/version.h
@@ -23,7 +23,7 @@
  */
 #ifndef _UCCP420WLAN_VERSION_H
 #define _UCCP420WLAN_VERSION_H
-#define UCCP_DRIVER_VERSION "4_5_5"
+#define UCCP_DRIVER_VERSION "4_5_8"
 #define UCCP_DRIVER_NAME "UCCP420WIFI"
 #endif /* _UCCP420WLAN_VERSION_H */
 
diff --git a/drivers/net/wireless/uccp420wlan/src/80211_if.c b/drivers/net/wireless/uccp420wlan/src/80211_if.c
index 2ed59e7..b6f13ff 100644
--- a/drivers/net/wireless/uccp420wlan/src/80211_if.c
+++ b/drivers/net/wireless/uccp420wlan/src/80211_if.c
@@ -287,6 +287,9 @@ static void tx(struct ieee80211_hw *hw,
 	unsigned char *pktgen_magic;
 	unsigned int orig_pktgen_magic = 0x55e99bbe; /*Endianness 0xbe9be955*/
 	struct umac_event_noa noa_event;
+#ifdef MULTI_CHAN_SUPPORT
+	int curr_chanctx_idx = -1;
+#endif
 
 	if (tx_info->control.vif == NULL) {
 		pr_debug("%s: Dropping injected TX frame\n",
@@ -337,13 +340,18 @@ static void tx(struct ieee80211_hw *hw,
 
 #ifdef MULTI_CHAN_SUPPORT
 	spin_lock_bh(&dev->chanctx_lock);
+	curr_chanctx_idx = dev->curr_chanctx_idx;
+	spin_unlock_bh(&dev->chanctx_lock);
 #endif
 
-	uccp420wlan_tx_frame(skb, txctl->sta, dev, false);
-
+	uccp420wlan_tx_frame(skb,
+			     txctl->sta,
+			     dev,
 #ifdef MULTI_CHAN_SUPPORT
-	spin_unlock_bh(&dev->chanctx_lock);
+			     curr_chanctx_idx,
 #endif
+			     false);
+
 	return;
 
 tx_status:
@@ -480,17 +488,12 @@ static int config(struct ieee80211_hw *hw,
 	struct mac80211_dev *dev = hw->priv;
 	struct ieee80211_conf *conf = &hw->conf;
 	unsigned int pri_chnl_num;
-	unsigned int chnl_num1;
-	unsigned int chnl_num2;
 	unsigned int freq_band;
 	unsigned int ch_width;
-	int center_freq = 0;
-	int center_freq1 = 0;
+	unsigned int center_freq = 0;
+	unsigned int center_freq1 = 0;
+	unsigned int center_freq2 = 0;
 	int i;
-	int cf_offset;
-	int is_vht_bw80;
-	int is_vht_bw80_sec_40minus;
-	int is_vht_bw80_sec_40plus;
 
 	DEBUG_LOG("%s-80211IF:In config\n", dev->name);
 
@@ -505,75 +508,18 @@ static int config(struct ieee80211_hw *hw,
 	if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
 		center_freq = conf->chandef.chan->center_freq;
 		center_freq1 = conf->chandef.center_freq1;
-		cf_offset = center_freq1;
-
-		pri_chnl_num = ieee80211_frequency_to_channel(center_freq);
+		center_freq2 = conf->chandef.center_freq2;
 		freq_band = conf->chandef.chan->band;
-
 		ch_width = conf->chandef.width;
 
+		pri_chnl_num = ieee80211_frequency_to_channel(center_freq);
 		DEBUG_LOG("%s-80211IF:Primary Channel is %d\n",
 			       dev->name,
 			       pri_chnl_num);
 
-		if (wifi->params.production_test == 1) {
-
-			if ((wifi->params.prod_mode_chnl_bw_40_mhz == 1) &&
-			    (wifi->params.sec_ch_offset_40_minus == 1)) {
-				/*  NL80211_CHAN_HT40MINUS */
-				ch_width = 2;
-				cf_offset = center_freq - 10;
-			} else if (wifi->params.prod_mode_chnl_bw_40_mhz == 1) {
-				/* NL80211_CHAN_HT40PLUS */
-				ch_width = 2;
-				cf_offset = center_freq + 10;
-			}
-
-			is_vht_bw80 = vht_support &&
-				(wifi->params.prod_mode_chnl_bw_80_mhz == 1);
-
-			is_vht_bw80_sec_40minus = is_vht_bw80 &&
-				(wifi->params.sec_ch_offset_40_minus == 1);
-
-			is_vht_bw80_sec_40plus = is_vht_bw80 &&
-				(wifi->params.sec_ch_offset_40_plus == 1);
-
-			if (is_vht_bw80)
-				ch_width = 3;
-
-			if (is_vht_bw80_sec_40minus &&
-			    (wifi->params.sec_40_ch_offset_80_minus == 1))
-				cf_offset = center_freq - 30;
-			else if (is_vht_bw80_sec_40minus &&
-				 (wifi->params.sec_40_ch_offset_80_plus == 1))
-				cf_offset = center_freq + 10;
-			else if (is_vht_bw80_sec_40minus)/* default */
-				cf_offset = center_freq - 30;
-
-			if (is_vht_bw80_sec_40plus &&
-			    (wifi->params.sec_40_ch_offset_80_minus == 1))
-				cf_offset = center_freq - 10;
-			else if (is_vht_bw80_sec_40plus &&
-				 (wifi->params.sec_40_ch_offset_80_plus == 1))
-				cf_offset = center_freq + 30;
-			else if (is_vht_bw80_sec_40plus)/* default */
-				cf_offset = center_freq - 10;
-		}
-
-		chnl_num1 = ieee80211_frequency_to_channel(cf_offset);
-		chnl_num2 = 0;
-
-		/*Store the currrent Channel*/
-		dev->cur_chan.pri_chnl_num = pri_chnl_num;
-		dev->cur_chan.chnl_num1 = chnl_num1;
-		dev->cur_chan.chnl_num2 = chnl_num2;
-		dev->cur_chan.ch_width  = ch_width;
-		dev->cur_chan.freq_band = freq_band;
-
 		dev->chan_prog_done = 0;
 		uccp420wlan_prog_channel(pri_chnl_num,
-					 chnl_num1,
-					 chnl_num2,
+					 center_freq1, center_freq2,
 					 ch_width,
 #ifdef MULTI_CHAN_SUPPORT
 					 0,
@@ -1040,8 +986,9 @@ static void bss_info_changed(struct ieee80211_hw *hw,
 	mutex_lock(&dev->mutex);
 
 	if (wifi->params.production_test || wifi->params.disable_beacon_ibss) {
-		/*Disable beacon generation when running pktgen
-		 *for performance*/
+		/* Disable beacon generation when running pktgen
+		 * for performance
+		 */
 		changed &= ~BSS_CHANGED_BEACON_INT;
 		changed &= ~BSS_CHANGED_BEACON_ENABLED;
 	}
@@ -1174,6 +1121,7 @@ static void init_hw(struct ieee80211_hw *hw)
 	hw->flags |= IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING;
 	hw->flags |= IEEE80211_HW_AMPDU_AGGREGATION;
 	hw->flags |= IEEE80211_HW_MFP_CAPABLE;
+	hw->flags |= IEEE80211_HW_REPORTS_TX_ACK_STATUS;
 
 	if (wifi->params.dot11a_support)
 		hw->flags |= IEEE80211_HW_SPECTRUM_MGMT;
@@ -1195,9 +1143,7 @@ static void init_hw(struct ieee80211_hw *hw)
 	/* Size */
 	hw->extra_tx_headroom = 0;
 	hw->vif_data_size = sizeof(struct umac_vif);
-#ifdef UNIFORM_BW_SHARING
 	hw->sta_data_size = sizeof(struct umac_sta);
-#endif
 #ifdef MULTI_CHAN_SUPPORT
 	hw->chanctx_data_size = sizeof(struct umac_chanctx);
 #endif
@@ -1365,8 +1311,8 @@ static void uccp420_roc_complete_work(struct work_struct *work)
 		dev->chan_prog_done = 0;
 
 		uccp420wlan_prog_channel(dev->cur_chan.pri_chnl_num,
-					 dev->cur_chan.chnl_num1,
-					 dev->cur_chan.chnl_num2,
+					 dev->cur_chan.center_freq1,
+					 dev->cur_chan.center_freq2,
 					 dev->cur_chan.ch_width,
 #ifdef MULTI_CHAN_SUPPORT
 					 0,
@@ -1414,7 +1360,6 @@ static int remain_on_channel(struct ieee80211_hw *hw,
 	struct mac80211_dev *dev = (struct mac80211_dev *)hw->priv;
 	unsigned int pri_chnl_num = 0;
 	unsigned int chnl_num1 = 0;
-	unsigned int chnl_num2 = 0;
 	unsigned int freq_band = channel->band;
 	unsigned int ch_width = 0; /* 20MHz */
 #ifdef MULTI_CHAN_SUPPORT
@@ -1460,9 +1405,9 @@ static int remain_on_channel(struct ieee80211_hw *hw,
 
 		dev->chan_prog_done = 0;
 
-		uccp420wlan_prog_channel(pri_chnl_num,
-					 chnl_num1,
-					 chnl_num2,
+		uccp420wlan_prog_channel(dev->cur_chan.pri_chnl_num,
+					channel->center_freq,
+					 0,
 					 ch_width,
 #ifdef MULTI_CHAN_SUPPORT
 					 uvif->vif_index,
@@ -1866,7 +1811,6 @@ int sta_add(struct ieee80211_hw *hw,
 	struct peer_sta_info peer_st_info = {0};
 	int i;
 	int result = 0;
-#ifdef UNIFORM_BW_SHARING
 	struct mac80211_dev *dev = hw->priv;
 	struct umac_sta *usta = (struct umac_sta *)sta->drv_priv;
 	unsigned int peer_id = 0;
@@ -1883,7 +1827,6 @@ int sta_add(struct ieee80211_hw *hw,
 		return -1;
 	}
 
-#endif
 
 	for (i = 0; i < STA_NUM_BANDS; i++)
 		peer_st_info.supp_rates[i] = sta->supp_rates[i];
@@ -1916,15 +1859,16 @@ int sta_add(struct ieee80211_hw *hw,
 
 	result = uccp420wlan_sta_add(uvif->vif_index, &peer_st_info);
 
-#ifdef UNIFORM_BW_SHARING
 	if (!result) {
 		rcu_assign_pointer(dev->peers[peer_id], sta);
 		synchronize_rcu();
 
 		usta->index = peer_id;
+#ifdef MULTI_CHAN_SUPPORT
 		usta->chanctx = uvif->chanctx;
-	}
+		usta->vif_index = uvif->vif_index;
 #endif
+	}
 
 	return result;
 }
@@ -1938,24 +1882,20 @@ int sta_remove(struct ieee80211_hw *hw,
 	struct peer_sta_info peer_st_info = {0};
 	int i;
 	int result = 0;
-#ifdef UNIFORM_BW_SHARING
 	struct mac80211_dev *dev = hw->priv;
 	struct umac_sta *usta = (struct umac_sta *)sta->drv_priv;
-#endif
 
 	for (i = 0; i < ETH_ALEN; i++)
 		peer_st_info.addr[i] = sta->addr[i];
 
 	result = uccp420wlan_sta_remove(uvif->vif_index, &peer_st_info);
 
-#ifdef UNIFORM_BW_SHARING
 	if (!result) {
 		rcu_assign_pointer(dev->peers[usta->index], NULL);
 		synchronize_rcu();
 
 		usta->index = -1;
 	}
-#endif
 
 	return result;
 }
@@ -2002,26 +1942,21 @@ static void umac_chanctx_set_channel(struct mac80211_dev *dev,
 				     struct umac_vif *uvif,
 				     struct cfg80211_chan_def *chandef)
 {
-	unsigned int pri_chan = 0;
-	unsigned int chan1 = 0;
-	unsigned int chan2 = 0;
 	unsigned int freq_band = 0;
 	unsigned int ch_width = 0;
-	int center_freq = 0;
 	int center_freq1 = 0;
+	int center_freq2 = 0;
+	unsigned int pri_chan;
 
-	center_freq = chandef->chan->center_freq;
+	pri_chan = ieee80211_frequency_to_channel(chandef->chan->center_freq);
 	center_freq1 = chandef->center_freq1;
-
-	pri_chan = ieee80211_frequency_to_channel(center_freq);
-	chan1 = ieee80211_frequency_to_channel(center_freq1);
+	center_freq2 = chandef->center_freq2;
 
 	freq_band = chandef->chan->band;
 	ch_width = chandef->width;
 
-	uccp420wlan_prog_channel(pri_chan,
-				 chan1,
-				 chan2,
+	uccp420wlan_prog_channel(pri_chan, center_freq1,
+				 center_freq2,
 				 ch_width,
 				 uvif->vif_index,
 				 freq_band);
@@ -2051,7 +1986,7 @@ static int add_chanctx(struct ieee80211_hw *hw,
 		return -1;
 	}
 
-	MULTI_CHAN_DEBUG("%s: %d MHz\n",
+	DEBUG_LOG("%s: %d MHz\n",
 			 __func__,
 			 conf->def.chan->center_freq);
 
@@ -2079,15 +2014,16 @@ static void remove_chanctx(struct ieee80211_hw *hw,
 	dev = hw->priv;
 	ctx = (struct umac_chanctx *)conf->drv_priv;
 
-	MULTI_CHAN_DEBUG("%s: %d MHz\n",
+	DEBUG_LOG("%s: %d MHz\n",
 			 __func__,
 			 conf->def.chan->center_freq);
 
 	mutex_lock(&dev->mutex);
 
-	/* unassign_vif_chanctx should have been called to free all the assigned
+	/* Unassign_vif_chanctx should have been called to free all the assigned
 	 * vifs before this call is called, hence we dont need to specifically
-	 * free the vifs here */
+	 * free the vifs here
+	 */
 	rcu_assign_pointer(dev->chanctx[ctx->index], NULL);
 	synchronize_rcu();
 
@@ -2109,13 +2045,13 @@ static void change_chanctx(struct ieee80211_hw *hw,
 	dev = hw->priv;
 	ctx = (struct umac_chanctx *)conf->drv_priv;
 
-	MULTI_CHAN_DEBUG("%s: %d MHz\n",
+	DEBUG_LOG("%s: %d MHz\n",
 			 __func__,
 			 conf->def.chan->center_freq);
 
 	/* SDK: See why this is needed */
 	if (dev->curr_chanctx_idx != ctx->index) {
-		MULTI_CHAN_DEBUG("Current ctx differs from the new ctx\n");
+		DEBUG_LOG("Current ctx differs from the new ctx\n");
 		return;
 	}
 
@@ -2140,7 +2076,7 @@ static int assign_vif_chanctx(struct ieee80211_hw *hw,
 	uvif = (struct umac_vif *)vif->drv_priv;
 	ctx = (struct umac_chanctx *)conf->drv_priv;
 
-	MULTI_CHAN_DEBUG("%s: addr: %pM, type: %d, p2p: %d chan: %d MHz\n",
+	DEBUG_LOG("%s: addr: %pM, type: %d, p2p: %d chan: %d MHz\n",
 			__func__,
 			vif->addr,
 			vif->type,
@@ -2156,7 +2092,8 @@ static int assign_vif_chanctx(struct ieee80211_hw *hw,
 	ctx->nvifs++;
 
 	/* If this is the first vif being assigned to the channel context then
-	 * increment our count of the active channel contexts */
+	 * increment our count of the active channel contexts
+	 */
 	if (prog_chanctx_time_info) {
 		if (!dev->num_active_chanctx)
 			dev->curr_chanctx_idx = ctx->index;
@@ -2185,7 +2122,7 @@ static void unassign_vif_chanctx(struct ieee80211_hw *hw,
 	uvif = (struct umac_vif *)vif->drv_priv;
 	ctx = (struct umac_chanctx *)conf->drv_priv;
 
-	MULTI_CHAN_DEBUG("%s: addr: %pM, type: %d, p2p: %d chan: %d MHz\n",
+	DEBUG_LOG("%s: addr: %pM, type: %d, p2p: %d chan: %d MHz\n",
 			 __func__,
 			 vif->addr,
 			 vif->type,
@@ -2208,6 +2145,115 @@ static void unassign_vif_chanctx(struct ieee80211_hw *hw,
 
 	mutex_unlock(&dev->mutex);
 }
+
+
+static void flush_queues(struct ieee80211_hw *hw,
+			 struct ieee80211_vif *vif,
+			 u32 queues,
+			 bool drop)
+{
+	struct mac80211_dev *dev = NULL;
+	struct umac_vif *uvif = NULL;
+	struct umac_chanctx *ctx = NULL;
+	unsigned int chan_ctx_id = 0;
+	unsigned int queue = 0;
+	unsigned int pending = 0;
+	int count = 0;
+	int peer_id = -1;
+	int i = 0;
+	unsigned long flags = 0;
+	struct sk_buff_head *pend_pkt_q = NULL;
+	struct tx_config *tx = NULL;
+	struct ieee80211_sta *sta = NULL;
+	struct umac_sta *usta = NULL;
+
+	dev = hw->priv;
+
+	mutex_lock(&dev->mutex);
+
+	tx = &dev->tx;
+
+	if (!vif)
+		goto out;
+
+	uvif = (struct umac_vif *)vif->drv_priv;
+
+	if (!uvif->chanctx)
+		goto out;
+
+	if (dev->num_active_chanctx != 2) {
+		DEBUG_LOG("%s-80211IF: Flush is only supported for TSMC case\n",
+			  __func__);
+		goto out;
+	}
+
+	ctx = uvif->chanctx;
+	chan_ctx_id = ctx->index;
+
+	for (queue = 0; queue < WLAN_AC_MAX_CNT; queue++) {
+		if (!((1 << queue) & queues))
+			continue;
+
+check_tokens_flush_complete:
+	pending = 0;
+
+	spin_lock_irqsave(&tx->lock, flags);
+	rcu_read_lock();
+
+	for (i = 0; i < MAX_PEND_Q_PER_AC; i++) {
+		if (i < MAX_PEERS) {
+			sta = rcu_dereference(dev->peers[i]);
+
+			if (!sta)
+				continue;
+
+			usta = (struct umac_sta *)(sta->drv_priv);
+
+			if (usta->vif_index == uvif->vif_index)
+				peer_id = i;
+			else
+				continue;
+		} else if (i == uvif->vif_index) {
+			peer_id = uvif->vif_index;
+		} else
+			continue;
+
+		pend_pkt_q = &tx->pending_pkt[peer_id][queue];
+
+		/* Assuming all packets for the peer have same channel
+		 * context
+		 */
+		pending = skb_queue_len(pend_pkt_q);
+	}
+
+	rcu_read_unlock();
+	spin_unlock_irqrestore(&tx->lock, flags);
+
+	if (pending && (count < QUEUE_FLUSH_TIMEOUT_TICKS)) {
+		current->state = TASK_INTERRUPTIBLE;
+
+		if (0 == schedule_timeout(1))
+			count++;
+
+		goto check_tokens_flush_complete;
+	}
+
+	if (pending)
+		DEBUG_LOG("%s: failed for VIF: %d and Queue: %d, pending: %d\n",
+				__func__,
+				uvif->vif_index,
+				queue,
+				pending);
+	else
+		DEBUG_LOG("%s: Flush for VIF: %d and Queue: %d success\n",
+				__func__,
+				uvif->vif_index,
+				queue);
+	}
+
+out:
+	mutex_unlock(&dev->mutex);
+}
 #endif
 
 
@@ -2250,6 +2296,7 @@ static struct ieee80211_ops ops = {
 	.change_chanctx           = change_chanctx,
 	.assign_vif_chanctx       = assign_vif_chanctx,
 	.unassign_vif_chanctx     = unassign_vif_chanctx,
+	.flush			  = flush_queues,
 #endif
 };
 
@@ -2394,6 +2441,7 @@ static int proc_read_config(struct seq_file *m, void *v)
 	int cnt = 0;
 	int rf_params_size = sizeof(wifi->params.rf_params) /
 			     sizeof(wifi->params.rf_params[0]);
+	struct mac80211_dev *dev = ((struct mac80211_dev *)(wifi->hw->priv));
 
 	seq_puts(m, "************* Configurable Parameters ***********\n");
 	seq_printf(m, "dot11g_support = %d\n", wifi->params.dot11g_support);
@@ -2573,6 +2621,9 @@ static int proc_read_config(struct seq_file *m, void *v)
 		seq_printf(m, "set_tx_power = %d dB\n",
 			   wifi->params.set_tx_power);
 
+	seq_printf(m, "center_frequency = %d\n",
+		   ieee80211_frequency_to_channel(dev->cur_chan.center_freq1));
+
 	if (ftm)
 		seq_printf(m, "aux_adc_chain_id = %d\n",
 			   wifi->params.aux_adc_chain_id);
@@ -2744,6 +2795,7 @@ static int proc_read_mac_stats(struct seq_file *m, void *v)
 	unsigned int total_value = 0;
 	int total_rssi_samples = 0;
 	int total_rssi_value = 0;
+	struct mac80211_dev *dev = NULL;
 
 	if (ftm) {
 		for (index = 0; index < MAX_AUX_ADC_SAMPLES; index++) {
@@ -2847,6 +2899,10 @@ static int proc_read_mac_stats(struct seq_file *m, void *v)
 		   wifi->stats.tx_cmd_send_count_multi);
 	seq_printf(m, "tx_done_recv_count = %d\n",
 		   wifi->stats.tx_done_recv_count);
+
+	dev = (struct mac80211_dev *)(wifi->hw->priv);
+	seq_printf(m, "tx_buff_pool_map = %ld\n",
+		   dev->tx.buf_pool_bmp[0]);
 	if (ftm)
 		seq_printf(m, "pdout_val = %d (total samples: %d)\n",
 			   total_samples ? (total_value/total_samples) : 0,
@@ -3655,15 +3711,8 @@ static ssize_t proc_write_config(struct file *file,
 	} else if ((wifi->params.production_test) &&
 		    param_get_val(buf, "start_prod_mode=", &val)) {
 			unsigned int pri_chnl_num = 0;
-			unsigned int chnl_num1 = 0;
-			unsigned int chnl_num2 = 0;
 			unsigned int freq_band = IEEE80211_BAND_5GHZ;
-			unsigned int ch_width = 0;
 			int center_freq = 0;
-			int cf_offset = 0;
-			int is_vht_bw80 = 0;
-			int is_vht_bw80_sec_40minus = 0;
-			int is_vht_bw80_sec_40plus = 0;
 			struct mac80211_dev *dev = wifi->hw->priv;
 
 			pri_chnl_num = val;
@@ -3678,51 +3727,6 @@ static ssize_t proc_write_config(struct file *file,
 			center_freq =
 			ieee80211_channel_to_frequency(pri_chnl_num,
 						       freq_band);
-			cf_offset = center_freq;
-
-			if ((wifi->params.prod_mode_chnl_bw_40_mhz == 1) &&
-			    (wifi->params.sec_ch_offset_40_minus == 1)) {
-				/*  NL80211_CHAN_HT40MINUS */
-				ch_width = 2;
-				cf_offset = center_freq - 10;
-			} else if (wifi->params.prod_mode_chnl_bw_40_mhz == 1) {
-				/* NL80211_CHAN_HT40PLUS */
-				ch_width = 2;
-				cf_offset = center_freq + 10;
-			}
-
-			is_vht_bw80 = vht_support &&
-				(wifi->params.prod_mode_chnl_bw_80_mhz == 1);
-
-			is_vht_bw80_sec_40minus = is_vht_bw80 &&
-				(wifi->params.sec_ch_offset_40_minus == 1);
-
-			is_vht_bw80_sec_40plus = is_vht_bw80 &&
-				(wifi->params.sec_ch_offset_40_plus == 1);
-
-			if (is_vht_bw80)
-				ch_width = 3;
-
-			if (is_vht_bw80_sec_40minus &&
-			    (wifi->params.sec_40_ch_offset_80_minus == 1))
-				cf_offset = center_freq - 30;
-			else if (is_vht_bw80_sec_40minus &&
-				 (wifi->params.sec_40_ch_offset_80_plus == 1))
-				cf_offset = center_freq + 10;
-			else if (is_vht_bw80_sec_40minus)/* default */
-				cf_offset = center_freq - 30;
-
-			if (is_vht_bw80_sec_40plus &&
-			    (wifi->params.sec_40_ch_offset_80_minus == 1))
-				cf_offset = center_freq - 10;
-			else if (is_vht_bw80_sec_40plus &&
-				 (wifi->params.sec_40_ch_offset_80_plus == 1))
-				cf_offset = center_freq + 30;
-			else if (is_vht_bw80_sec_40plus)/* default */
-				cf_offset = center_freq - 10;
-
-			chnl_num1 = ieee80211_frequency_to_channel(cf_offset);
-			chnl_num2 = 0;
 
 			if ((wifi->params.fw_loading == 1) &&
 			     load_fw(dev->hw)) {
@@ -3740,8 +3744,10 @@ static ssize_t proc_write_config(struct file *file,
 						val);
 
 				uccp420wlan_prog_channel(pri_chnl_num,
-							 chnl_num1,
-							 chnl_num2, ch_width,
+							center_freq,
+							 0,
+							 0,
+					/*It will be overwritten anyway*/
 #ifdef MULTI_CHAN_SUPPORT
 							 0,
 #endif
@@ -3758,14 +3764,15 @@ static ssize_t proc_write_config(struct file *file,
 			struct mac80211_dev *dev = wifi->hw->priv;
 
 			tasklet_kill(&dev->proc_tx_tasklet);
-			#if 0
+#if 0
 			/* Todo: Enabling this causes RPU Lockup,
-			 * need to debug */
+			 * need to debug
+			 */
 			uccp420wlan_prog_vif_ctrl(0,
 						  dev->if_mac_addresses[0].addr,
 						  IF_MODE_STA_IBSS,
 						  IF_REM);
-			#endif
+#endif
 			uccp420wlan_core_deinit(dev, 0);
 			wifi->params.start_prod_mode = 0;
 			wifi->params.pkt_gen_val = 1;
@@ -3786,7 +3793,7 @@ static ssize_t proc_write_config(struct file *file,
 			wifi->params.pkt_gen_val = 1;
 			tasklet_kill(&dev->proc_tx_tasklet);
 	} else if ((wifi->params.production_test) &&
-		    param_get_sval(buf, "payload_length=", &sval)) {
+		    param_get_val(buf, "payload_length=", &val)) {
 			wifi->params.payload_length = val;
 	} else if ((ftm || wifi->params.production_test) &&
 		    param_get_sval(buf, "set_tx_power=", &sval)) {
diff --git a/drivers/net/wireless/uccp420wlan/src/core.c b/drivers/net/wireless/uccp420wlan/src/core.c
index 417cecd..9df0fda 100644
--- a/drivers/net/wireless/uccp420wlan/src/core.c
+++ b/drivers/net/wireless/uccp420wlan/src/core.c
@@ -293,8 +293,22 @@ static void vif_bcn_timer_expiry(unsigned long data)
 
 		spin_lock_irqsave(&uvif->dev->bcast_lock, flags);
 
-		while ((skb = skb_dequeue(&bcast_frames)))
-			uccp420wlan_tx_frame(skb, NULL, uvif->dev, true);
+		while ((skb = skb_dequeue(&bcast_frames))) {
+			/* For a Beacon queue we will let the frames pass
+			 * through irrespective of the current channel context.
+			 * The FW will take care of transmitting them in the
+			 * appropriate channel. Hence pass the interfaces
+			 * channel context instead of the actual current channel
+			 * context.
+			 */
+			uccp420wlan_tx_frame(skb,
+					     NULL,
+					     uvif->dev,
+#ifdef MULTI_CHAN_SUPPORT
+					     uvif->chanctx->index,
+#endif
+					     true);
+		}
 
 		spin_unlock_irqrestore(&uvif->dev->bcast_lock, flags);
 
@@ -304,7 +318,19 @@ static void vif_bcn_timer_expiry(unsigned long data)
 		if (!skb)
 			goto reschedule_timer;
 
-		uccp420wlan_tx_frame(skb, NULL, uvif->dev, true);
+		/* For a Beacon queue we will let the frames pass through
+		 * irrespective of the current channel context. The FW will take
+		 * care of transmitting them in the appropriate channel.  Hence
+		 * pass the interfaces channel context instead of the actual
+		 * current channel context.
+		 */
+		uccp420wlan_tx_frame(skb,
+				     NULL,
+				     uvif->dev,
+#ifdef MULTI_CHAN_SUPPORT
+				     uvif->chanctx->index,
+#endif
+				     true);
 
 	}
 reschedule_timer:
@@ -908,6 +934,9 @@ void uccp420wlan_noa_event(int event, struct umac_event_noa *noa, void *context,
 	struct umac_vif *uvif;
 	unsigned long flags;
 	bool transmit = false;
+#ifdef MULTI_CHAN_SUPPORT
+	int curr_chanctx_idx = -1;
+#endif
 
 	rcu_read_lock();
 
@@ -970,8 +999,20 @@ void uccp420wlan_noa_event(int event, struct umac_event_noa *noa, void *context,
 
 	rcu_read_unlock();
 
-	if (transmit)
-		uccp420wlan_tx_frame(skb, NULL, dev, false);
+	if (transmit) {
+#ifdef MULTI_CHAN_SUPPORT
+		spin_lock_bh(&dev->chanctx_lock);
+		curr_chanctx_idx = dev->curr_chanctx_idx;
+		spin_unlock_bh(&dev->chanctx_lock);
+#endif
+		uccp420wlan_tx_frame(skb,
+				     NULL,
+				     dev,
+#ifdef MULTI_CHAN_SUPPORT
+				     curr_chanctx_idx,
+#endif
+				     false);
+	}
 }
 
 #if 0
@@ -1020,11 +1061,7 @@ void uccp420wlan_proc_ch_sw_event(struct umac_event_ch_switch *ch_sw_info,
 	int curr_bit = 0;
 	int pool_id = 0;
 	int ret = 0;
-#ifdef UNIFORM_BW_SHARING
 	int peer_id = -1;
-#else
-	int pkts_pend = 0;
-#endif
 	int ac = 0;
 	struct ieee80211_chanctx_conf *curr_chanctx = NULL;
 	struct tx_config *tx = NULL;
@@ -1056,17 +1093,21 @@ void uccp420wlan_proc_ch_sw_event(struct umac_event_ch_switch *ch_sw_info,
 	rcu_read_unlock();
 
 	if (i == MAX_CHANCTX) {
-		pr_err("%s: Invalid Channel Context\n", __func__);
+		pr_err("%s: Invalid Channel Context: chan: %d\n",
+		       __func__,
+		       chan);
 		return;
 	}
 
 
 	/* Switch to the new channel context */
-	/* SDK: Take care of locking requirements for these elements */
+	spin_lock(&dev->chanctx_lock);
 	dev->curr_chanctx_idx = chan_id;
+	spin_unlock(&dev->chanctx_lock);
 
 	/* We now try to xmit any frames whose xmission got cancelled due to a
-	 * previous channel switch */
+	 * previous channel switch
+	 */
 	for (i = 0; i < NUM_TX_DESCS; i++) {
 		spin_lock_irqsave(&tx->lock, flags);
 
@@ -1078,25 +1119,19 @@ void uccp420wlan_proc_ch_sw_event(struct umac_event_ch_switch *ch_sw_info,
 			continue;
 		}
 
-
-		txq = &tx->pkt_info[dev->curr_chanctx_idx][i].pkt;
+		txq = &tx->pkt_info[chan_id][i].pkt;
 		txq_len = skb_queue_len(txq);
-		queue = tx->pkt_info[dev->curr_chanctx_idx][i].queue;
+		queue = tx->pkt_info[chan_id][i].queue;
 
 		if (!txq_len) {
 			/* Reserved token */
 			if (i < (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
 				queue = (i % NUM_ACS);
-#ifdef UNIFORM_BW_SHARING
-				peer_id = get_curr_peer_opp(dev, queue);
+				peer_id = get_curr_peer_opp(dev,
+							    chan_id,
+							    queue);
 
 				if (peer_id == -1) {
-#else
-				pkts_pend =
-					skb_queue_len(&tx->pending_pkt[queue]);
-
-				if (!pkts_pend) {
-#endif
 					/* Mark the token as available */
 					__clear_bit(curr_bit,
 						    &tx->buf_pool_bmp[pool_id]);
@@ -1109,23 +1144,17 @@ void uccp420wlan_proc_ch_sw_event(struct umac_event_ch_switch *ch_sw_info,
 			/* Spare token */
 			} else {
 				for (ac = WLAN_AC_VO; ac >= 0; ac--) {
-#ifdef UNIFORM_BW_SHARING
-					peer_id = get_curr_peer_opp(dev, ac);
+					peer_id = get_curr_peer_opp(dev,
+								    chan_id,
+								    ac);
 
 					if (peer_id != -1) {
-#else
-					pkts_pend =
-					   skb_queue_len(&tx->pending_pkt[ac]);
-
-					if (pkts_pend) {
-#endif
 						queue = ac;
 						break;
 					}
 				}
 
 				if (ac < 0) {
-
 					/* Mark the token as available */
 					__clear_bit(curr_bit,
 						    &tx->buf_pool_bmp[pool_id]);
@@ -1138,9 +1167,8 @@ void uccp420wlan_proc_ch_sw_event(struct umac_event_ch_switch *ch_sw_info,
 
 			uccp420wlan_tx_proc_pend_frms(dev,
 						      queue,
-#ifdef UNIFORM_BW_SHARING
+						      chan_id,
 						      peer_id,
-#endif
 						      i);
 
 			tx->outstanding_tokens[queue]++;
@@ -1152,21 +1180,25 @@ void uccp420wlan_proc_ch_sw_event(struct umac_event_ch_switch *ch_sw_info,
 		ret = __uccp420wlan_tx_frame(dev,
 					     queue,
 					     i,
+					     chan_id,
+					     0,
 					     0); /* TODO: Currently sending 0
 						    since this param is not used
 						    as expected in the orig
 						    code for multiple frames etc
 						    Need to set this
 						    properly when the orig code
-						    logic is corrected */
+						    logic is corrected
+						  */
 		if (ret < 0) {
 			/* SDK: Check if we need to clear the TX bitmap and
-			 * desc_chan_map here */
+			 * desc_chan_map here
+			 */
 			pr_err("%s: Queueing of TX frame to FW failed\n",
 			       __func__);
 		} else {
 			spin_lock_irqsave(&tx->lock, flags);
-			tx->desc_chan_map[i] = dev->curr_chanctx_idx;
+			tx->desc_chan_map[i] = chan_id;
 			spin_unlock_irqrestore(&tx->lock, flags);
 		}
 
@@ -1369,10 +1401,11 @@ void uccp420wlan_rx_frame(struct sk_buff *skb, void *context)
 				memcpy(&ldelta, &rx->reserved[12], 4);
 				dev->params->sync[i].atu = 0;
 				/* ts2 = get_real_ts2(ts2, ldelta); */
-				if (frc_to_atu)
+				if (frc_to_atu) {
 					frc_to_atu(ts2,
 						&dev->params->sync[i].atu, 0);
 				dev->params->sync[i].atu -= ldelta * 1000;
+				}
 				spin_unlock(&tsf_lock);
 				break;
 			}
diff --git a/drivers/net/wireless/uccp420wlan/src/hal_hostport.c b/drivers/net/wireless/uccp420wlan/src/hal_hostport.c
index 446a473..b00a6a9 100644
--- a/drivers/net/wireless/uccp420wlan/src/hal_hostport.c
+++ b/drivers/net/wireless/uccp420wlan/src/hal_hostport.c
@@ -1624,7 +1624,8 @@ int hal_map_tx_buf(int pkt_desc, int frame_id, unsigned char *data, int len)
 	dma_addr_t dma_buf = 0;
 
 	/* For QoS Null frames we dont try to map the frame since the data len
-	 * will be 0 and there is nothing for the FW to process */
+	 * will be 0 and there is nothing for the FW to process
+	 */
 	if (len == 0)
 		return 0;
 
@@ -1689,7 +1690,8 @@ int hal_unmap_tx_buf(int pkt_desc, int frame_id)
 
 	/* For QoS Null frames we did not map the frame (since the data len
 	 * will be 0 and there is nothing for the FW to process), hence no need
-	 * to try and unmap */
+	 * to try and unmap
+	 */
 	if (!hpriv->tx_buf_info[index].dma_buf_len)
 		return 0;
 
diff --git a/drivers/net/wireless/uccp420wlan/src/tx.c b/drivers/net/wireless/uccp420wlan/src/tx.c
index 314dc3f..04db7b9 100644
--- a/drivers/net/wireless/uccp420wlan/src/tx.c
+++ b/drivers/net/wireless/uccp420wlan/src/tx.c
@@ -224,6 +224,9 @@ static void tx_status(struct sk_buff *skb,
 
 
 static int get_token(struct mac80211_dev *dev,
+#ifdef MULTI_CHAN_SUPPORT
+		     int curr_chanctx_idx,
+#endif
 		     int queue)
 {
 	int cnt = 0;
@@ -234,16 +237,19 @@ static int get_token(struct mac80211_dev *dev,
 
 	/* First search for a reserved token */
 	for (cnt = 0; cnt < NUM_TX_DESCS_PER_AC; cnt++) {
-		if (!test_and_set_bit((queue + (NUM_ACS * cnt)),
-							&tx->buf_pool_bmp[0])) {
+		curr_bit = ((queue + (NUM_ACS * cnt)) % TX_DESC_BUCKET_BOUND);
+		pool_id = ((queue + (NUM_ACS * cnt)) / TX_DESC_BUCKET_BOUND);
 
+		if (!test_and_set_bit(curr_bit, &tx->buf_pool_bmp[pool_id])) {
 			token_id = queue + (NUM_ACS * cnt);
 			break;
 		}
 	}
 
-	/* If reserved token is not found search for a spare token */
-	if (cnt == NUM_TX_DESCS_PER_AC) {
+	/* If reserved token is not found search for a spare token
+	 * (only for non beacon queues)
+	 */
+	if ((cnt == NUM_TX_DESCS_PER_AC) && (queue != WLAN_AC_BCN)) {
 		for (token_id = NUM_TX_DESCS_PER_AC * NUM_ACS;
 		     token_id < NUM_TX_DESCS;
 		     token_id++) {
@@ -260,7 +266,7 @@ static int get_token(struct mac80211_dev *dev,
 	if (token_id != NUM_TX_DESCS) {
 		tx->outstanding_tokens[queue]++;
 #ifdef MULTI_CHAN_SUPPORT
-		tx->desc_chan_map[token_id] = dev->curr_chanctx_idx;
+		tx->desc_chan_map[token_id] = curr_chanctx_idx;
 #endif
 	}
 
@@ -268,8 +274,10 @@ static int get_token(struct mac80211_dev *dev,
 }
 
 
-#ifdef UNIFORM_BW_SHARING
 int get_curr_peer_opp(struct mac80211_dev *dev,
+#ifdef MULTI_CHAN_SUPPORT
+		      int curr_chanctx_idx,
+#endif
 		      int queue)
 {
 	unsigned int curr_peer_opp = 0;
@@ -287,7 +295,7 @@ int get_curr_peer_opp(struct mac80211_dev *dev,
 	tx = &dev->tx;
 
 #ifdef MULTI_CHAN_SUPPORT
-	init_peer_opp = tx->curr_peer_opp[dev->curr_chanctx_idx][queue];
+	init_peer_opp = tx->curr_peer_opp[curr_chanctx_idx][queue];
 #else
 	init_peer_opp = tx->curr_peer_opp[queue];
 #endif
@@ -313,7 +321,7 @@ int get_curr_peer_opp(struct mac80211_dev *dev,
 				continue;
 			}
 
-			if (usta->chanctx->index != dev->curr_chanctx_idx) {
+			if (usta->chanctx->index != curr_chanctx_idx) {
 				rcu_read_unlock();
 				continue;
 			}
@@ -335,7 +343,7 @@ int get_curr_peer_opp(struct mac80211_dev *dev,
 				continue;
 			}
 
-			if (uvif->chanctx->index != dev->curr_chanctx_idx) {
+			if (uvif->chanctx->index != curr_chanctx_idx) {
 				rcu_read_unlock();
 				continue;
 			}
@@ -346,7 +354,7 @@ int get_curr_peer_opp(struct mac80211_dev *dev,
 
 		if (skb_queue_len(&tx->pending_pkt[curr_peer_opp][queue])) {
 #ifdef MULTI_CHAN_SUPPORT
-			tx->curr_peer_opp[dev->curr_chanctx_idx][queue] =
+			tx->curr_peer_opp[curr_chanctx_idx][queue] =
 				(curr_peer_opp + 1) % MAX_PEND_Q_PER_AC;
 #else
 			tx->curr_peer_opp[queue] =
@@ -361,14 +369,14 @@ int get_curr_peer_opp(struct mac80211_dev *dev,
 
 	return curr_peer_opp;
 }
-#endif
 
 
 void uccp420wlan_tx_proc_pend_frms(struct mac80211_dev *dev,
 				   int queue,
-#ifdef UNIFORM_BW_SHARING
-				   int peer_id,
+#ifdef MULTI_CHAN_SUPPORT
+				   int curr_chanctx_idx,
 #endif
+				   int peer_id,
 				   int token_id)
 {
 	struct tx_config *tx = &dev->tx;
@@ -386,20 +394,11 @@ void uccp420wlan_tx_proc_pend_frms(struct mac80211_dev *dev,
 	unsigned int max_tx_cmds = dev->params->max_tx_cmds;
 	struct sk_buff_head *txq = NULL;
 	struct sk_buff_head *pend_pkt_q = NULL;
-#ifdef MULTI_CHAN_SUPPORT
-	int chanctx_idx = 0;
-#endif
 
-#ifdef UNIFORM_BW_SHARING
 	pend_pkt_q = &tx->pending_pkt[peer_id][queue];
-#else
-	pend_pkt_q = &tx->pending_pkt[queue];
-#endif
 
 #ifdef MULTI_CHAN_SUPPORT
-	chanctx_idx = dev->curr_chanctx_idx;
-
-	txq = &dev->tx.pkt_info[chanctx_idx][token_id].pkt;
+	txq = &dev->tx.pkt_info[curr_chanctx_idx][token_id].pkt;
 #else
 	txq = &dev->tx.pkt_info[token_id].pkt;
 #endif
@@ -419,7 +418,8 @@ void uccp420wlan_tx_proc_pend_frms(struct mac80211_dev *dev,
 		max_tx_cmds = 16;
 
 	/* Aggregate Only MPDU's with same RA, same Rate,
-	 * same Rate flags, same Tx Info flags */
+	 * same Rate flags, same Tx Info flags
+	 */
 	skb_queue_walk_safe(pend_pkt_q,
 			    loop_skb,
 			    tmp) {
@@ -468,10 +468,9 @@ int uccp420wlan_tx_alloc_buff_req(struct mac80211_dev *dev,
 				  int queue,
 #ifdef MULTI_CHAN_SUPPORT
 				  struct umac_vif *uvif,
+				  int curr_chanctx_idx,
 #endif
-#ifdef UNIFORM_BW_SHARING
 				  int peer_id,
-#endif
 				  struct sk_buff *skb)
 {
 	int token_id = NUM_TX_DESCS;
@@ -479,84 +478,87 @@ int uccp420wlan_tx_alloc_buff_req(struct mac80211_dev *dev,
 	struct sk_buff_head *txq = NULL;
 	unsigned long flags = 0;
 	struct sk_buff_head *pend_pkt_q = NULL;
-#ifdef UNIFORM_BW_SHARING
 	int tx_peer_id = 0;
-#endif
 	struct ieee80211_hdr *mac_hdr = NULL;
 
 	spin_lock_irqsave(&tx->lock, flags);
 
-#ifdef UNIFORM_BW_SHARING
 	pend_pkt_q = &tx->pending_pkt[peer_id][queue];
-#else
-	pend_pkt_q = &tx->pending_pkt[queue];
-#endif
 
 	DEBUG_LOG("%s-UMACTX:Alloc buf Req q = %d,\n", dev->name, queue);
 
 #ifdef MULTI_CHAN_SUPPORT
-	if (uvif->chanctx->index == dev->curr_chanctx_idx)
+	if (uvif->chanctx->index == curr_chanctx_idx)
+		token_id = get_token(dev,
+				     curr_chanctx_idx,
+				     queue);
+#else
+	token_id = get_token(dev,
+			     queue);
 #endif
-		token_id = get_token(dev, queue);
+
 
 	/* If we got a reserved token, then queue frame to the Xmit queue */
 	if (token_id < NUM_TX_DESCS_PER_AC * NUM_ACS) {
 		DEBUG_LOG("%s-UMACTX:Reserved Token, Sending single\n",
 			  dev->name);
 #ifdef MULTI_CHAN_SUPPORT
-		txq = &dev->tx.pkt_info[dev->curr_chanctx_idx][token_id].pkt;
+		txq = &dev->tx.pkt_info[curr_chanctx_idx][token_id].pkt;
 #else
 		txq = &dev->tx.pkt_info[token_id].pkt;
 #endif
 		skb_queue_tail(txq, skb);
 	} else {
-		/* The probability of a beacon frame not getting a reserved
-		 * token is very low due since we request a beacon frame only
-		 * when a reserved token is freed up. */
-#ifdef MULTI_CHAN_SUPPORT
-		if (uvif->chanctx->index == dev->curr_chanctx_idx) {
-#endif
-			mac_hdr = (struct ieee80211_hdr *)(skb->data);
-
-			if ((queue == WLAN_AC_BCN) &&
-			    (ieee80211_is_beacon(mac_hdr->frame_control))) {
-				/* TODO: Need to see how to handle the beacon
-				 * frame in such a case i.e. whether it is worth
-				 * queuing it */
-				pr_err("Did not get rsvd token for beacon\n");
-			}
+		/* A frame for a beacon queue should never get a reserved
+		 * token
+		 */
+		mac_hdr = (struct ieee80211_hdr *)(skb->data);
 
-#ifdef MULTI_CHAN_SUPPORT
+		if ((queue == WLAN_AC_BCN) &&
+		    (ieee80211_is_beacon(mac_hdr->frame_control))) {
+			if (net_ratelimit())
+				pr_warn("Did not get rsvd token for beacon\n");
 		}
-#endif
 
 		/* Queue the frame to the pending frames queue */
 		skb_queue_tail(pend_pkt_q, skb);
 
-		/* Take steps to stop the TX traffic if we have reached the
-		 * queueing limit */
-		if (skb_queue_len(pend_pkt_q) >= MAX_TX_QUEUE_LEN) {
-			ieee80211_stop_queue(dev->hw,
-					     skb->queue_mapping);
-			tx->queue_stopped_bmp |= (1 << queue);
-		}
+		if (queue != WLAN_AC_BCN) {
+			/* Take steps to stop the TX traffic if we have reached
+			 * the queueing limit
+			 */
+			if (skb_queue_len(pend_pkt_q) >= MAX_TX_QUEUE_LEN) {
+				ieee80211_stop_queue(dev->hw,
+						     skb->queue_mapping);
+				tx->queue_stopped_bmp |= (1 << queue);
+			}
 
-		/* If we got a spare token, try sending out pending frames */
-		if (token_id < NUM_TX_DESCS) {
-#ifdef UNIFORM_BW_SHARING
-			tx_peer_id = get_curr_peer_opp(dev, queue);
+			/* If we got a spare token, try sending out pending
+			 * frames
+			 */
+			if (token_id < NUM_TX_DESCS) {
+				tx_peer_id = get_curr_peer_opp(dev,
+#ifdef MULTI_CHAN_SUPPORT
+							       curr_chanctx_idx,
 #endif
+							       queue);
 
-			uccp420wlan_tx_proc_pend_frms(dev,
-						      queue,
-#ifdef UNIFORM_BW_SHARING
-						      tx_peer_id,
+				uccp420wlan_tx_proc_pend_frms(dev,
+							      queue,
+#ifdef MULTI_CHAN_SUPPORT
+							      curr_chanctx_idx,
 #endif
-						      token_id);
+							      tx_peer_id,
+							      token_id);
+			}
 		}
 	}
 
-	DEBUG_LOG("%s-UMACTX:Alloc buf Result *id = %d\n", dev->name, token_id);
+	DEBUG_LOG("%s-UMACTX:Alloc buf Result *id = %d q = %d peer_id = %d\n",
+		  dev->name,
+		  token_id
+		  queue,
+		  peer_id);
 
 	spin_unlock_irqrestore(&tx->lock, flags);
 
@@ -564,10 +566,27 @@ int uccp420wlan_tx_alloc_buff_req(struct mac80211_dev *dev,
 	return token_id;
 }
 
+int get_band_chanctx(struct mac80211_dev *dev, struct umac_vif *uvif)
+{
+	struct ieee80211_chanctx_conf *chanctx = NULL;
+	int index = 0;
+	int band = 0;
+
+	rcu_read_lock();
+	index = uvif->chanctx->index;
+	chanctx = rcu_dereference(dev->chanctx[index]);
+	band = (chanctx->def.chan)->band;
+	rcu_read_unlock();
+
+	return band;
+}
 
 int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 				 struct umac_event_tx_done *tx_done,
 				 unsigned char *queue,
+#ifdef MULTI_CHAN_SUPPORT
+				 int curr_chanctx_idx,
+#endif
 				 int *vif_index_bitmap)
 {
 	int i = 0;
@@ -579,20 +598,18 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 	struct ieee80211_tx_info tx_info_1st_mpdu;
 	struct sk_buff *skb, *tmp, *skb_first = NULL;
 	struct sk_buff_head *skb_list, tx_done_list;
-	int vif_index;
+	int vif_index = -1;
 	unsigned int pkt = 0;
 	int cnt = 0;
 	int bit = 0;
 	int pool_id = 0;
 	unsigned int desc_id = tx_done->descriptor_id;
 	unsigned int max_tx_cmds = dev->params->max_tx_cmds;
-	struct umac_vif *uvif;
-	struct ieee80211_vif *ivif;
+	struct umac_vif *uvif = NULL;
+	struct ieee80211_vif *ivif = NULL;
 	unsigned long bcn_int = 0;
 	int pend_pkt_q_len = 0;
-#ifdef UNIFORM_BW_SHARING
 	int peer_id = 0;
-#endif
 #ifdef MULTI_CHAN_SUPPORT
 	int chanctx_idx = 0;
 #endif
@@ -600,9 +617,9 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 	skb_queue_head_init(&tx_done_list);
 
 	DEBUG_LOG("%s-UMACTX:Free buf Req q = %d, desc_id: %d\n",
-	       dev->name,
-	       tx_done->queue,
-	       desc_id);
+		  dev->name,
+		  tx_done->queue,
+		  desc_id);
 
 	spin_lock_irqsave(&tx->lock, flags);
 
@@ -612,85 +629,59 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 	chanctx_idx = tx->desc_chan_map[desc_id];
 #endif
 
+	bit = (desc_id % TX_DESC_BUCKET_BOUND);
+	pool_id = (desc_id / TX_DESC_BUCKET_BOUND);
+
+	/* Reserved token */
 	if (desc_id < (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
-		/* Reserved token */
 		*queue = tx_done->queue;
 
-		if (*queue != WLAN_AC_BCN) {
-#ifdef UNIFORM_BW_SHARING
-			peer_id = get_curr_peer_opp(dev, *queue);
-
-			if (peer_id == -1) {
-#else
-			pkts_pend = skb_queue_len(&tx->pending_pkt[*queue]);
-
-			if (!pkts_pend) {
+		peer_id = get_curr_peer_opp(dev,
+#ifdef MULTI_CHAN_SUPPORT
+					    curr_chanctx_idx,
 #endif
-					__clear_bit(desc_id,
-						    &tx->buf_pool_bmp[0]);
+					    *queue);
+
+		if (peer_id == -1) {
+			__clear_bit(bit, &tx->buf_pool_bmp[pool_id]);
 #ifdef MULTI_CHAN_SUPPORT
-					tx->desc_chan_map[desc_id] = -1;
+			tx->desc_chan_map[desc_id] = -1;
 #endif
-				}
-			} else {
-				__clear_bit(desc_id,
-					    &tx->buf_pool_bmp[0]);
+		}
+	/* Spare token */
+	} else {
+		for (cnt = WLAN_AC_VO; cnt >= 0; cnt--) {
+			peer_id = get_curr_peer_opp(dev,
 #ifdef MULTI_CHAN_SUPPORT
-				tx->desc_chan_map[desc_id] = -1;
+						    curr_chanctx_idx,
 #endif
-			}
-		} else {
-			/* Spare token */
-			for (cnt = WLAN_AC_VO; cnt >= 0; cnt--) {
-#ifdef UNIFORM_BW_SHARING
-				peer_id = get_curr_peer_opp(dev, cnt);
+						    cnt);
 
-				if (peer_id != -1) {
-#else
-				pkts_pend =
-					skb_queue_len(&tx->pending_pkt[cnt]);
-
-				if (pkts_pend) {
-#endif
-						*queue = cnt;
-						break;
-					}
-				}
-
-				/* If beacon queue has pending and no other AC
-				   has pending*/
-#ifdef UNIFORM_BW_SHARING
-				if (peer_id == -1) {
-#else
-				if (!pkts_pend) {
-#endif
-					bit = (desc_id %
-					       TX_DESC_BUCKET_BOUND);
-					pool_id = (desc_id /
-						   TX_DESC_BUCKET_BOUND);
+			if (peer_id != -1) {
+				*queue = cnt;
+				break;
+			}
+		}
 
-					__clear_bit(bit,
-						    &tx->buf_pool_bmp[pool_id]);
+		/* If beacon queue has pending and no other AC
+		 *  has pending
+		 */
+		if (peer_id == -1) {
+			__clear_bit(bit, &tx->buf_pool_bmp[pool_id]);
 #ifdef MULTI_CHAN_SUPPORT
-					tx->desc_chan_map[desc_id] = -1;
+			tx->desc_chan_map[desc_id] = -1;
 #endif
-				}
-			}
+		}
+	}
 
-#ifdef UNIFORM_BW_SHARING
 	if (peer_id != -1)
 		pkts_pend = skb_queue_len(&tx->pending_pkt[peer_id][*queue]);
 
 	DEBUG_LOG("%s-UMACTX:%s pend_q = %d, sta_id = %d desc_id: %d pend:%d\n",
-#else
-	DEBUG_LOG("%s-UMACTX:%s pend_q = %d, desc_id: %d pend:%d\n",
-#endif
 		  dev->name,
 		  __func__,
 		  *queue,
-#ifdef UNIFORM_BW_SHARING
 		  peer_id,
-#endif
 		  desc_id,
 		  pkts_pend);
 
@@ -706,32 +697,45 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 		skb_queue_splice_tail_init(skb_list, &tx_done_list);
 	} else {
 		DEBUG_LOG("%s-UMACTX:Got Empty List: list_addr: %p\n",
-			dev->name, skb_list);
+			  dev->name, skb_list);
 	}
 
 	if (pkts_pend > 0) {
+		/* For a beacon queue we will process the frames irrespective
+		 * of the current channel context. The FW will take care of
+		 * transmitting them in the appropriate channel. Hence pass the
+		 * interfaces channel context instead of the actual current
+		 * channel context.
+		 */
+		if (*queue == WLAN_AC_BCN) {
+			rcu_read_lock();
+
+			vif_index = (peer_id - MAX_PEERS);
+			ivif = rcu_dereference(dev->vifs[vif_index]);
+			uvif = (struct umac_vif *)(ivif->drv_priv);
+			curr_chanctx_idx = uvif->chanctx->index;
+			rcu_read_unlock();
+		}
+
 		uccp420wlan_tx_proc_pend_frms(dev,
 					      *queue,
-#ifdef UNIFORM_BW_SHARING
-					      peer_id,
+#ifdef MULTI_CHAN_SUPPORT
+					      curr_chanctx_idx,
 #endif
+					      peer_id,
 					      desc_id);
 
 		tx->outstanding_tokens[*queue]++;
 
 		DEBUG_LOG("%s-UMACTX:Pending packets: %d, Total: %d\n",
-		       dev->name,
-		       pkts_pend,
-		       skb_queue_len(skb_list));
+			  dev->name,
+			  pkts_pend,
+			  skb_queue_len(skb_list));
 	} else {
 		DEBUG_LOG("%s-UMACTX:No Pending Packets\n", dev->name);
 	}
 
-#ifdef UNIFORM_BW_SHARING
 	pend_pkt_q_len = skb_queue_len(&tx->pending_pkt[peer_id][*queue]);
-#else
-	pend_pkt_q_len = skb_queue_len(&tx->pending_pkt[*queue]);
-#endif
 
 	if ((*queue != WLAN_AC_BCN) &&
 	    (tx->queue_stopped_bmp & (1 << *queue)) &&
@@ -744,12 +748,14 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 	if (skb_queue_len(&tx_done_list)) {
 		skb_queue_walk_safe(&tx_done_list, skb, tmp) {
 			hal_ops.unmap_tx_buf(tx_done->descriptor_id, pkt);
+
 			DEBUG_LOG("%s-UMACTX:TXDONE: ID=%d, Stat=%d (%d, %d)\n",
-				dev->name,
-				tx_done->descriptor_id,
-				tx_done->frm_status[pkt],
-				tx_done->rate[pkt],
-				tx_done->retries_num[pkt]);
+				  dev->name,
+				  tx_done->descriptor_id,
+				  tx_done->frm_status[pkt],
+				  tx_done->rate[pkt],
+				  tx_done->retries_num[pkt]);
+
 			pkt++;
 		}
 	}
@@ -769,7 +775,9 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 	memcpy(&tx_info_1st_mpdu,
 	       (struct ieee80211_tx_info *)IEEE80211_SKB_CB(skb_first),
 	       sizeof(struct ieee80211_tx_info));
+
 	pkt = 0;
+
 	skb_queue_walk_safe(&tx_done_list, skb, tmp) {
 		__skb_unlink(skb, &tx_done_list);
 
@@ -820,8 +828,11 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 			/* Beacon Time Stamp */
 			if (tx_done->frm_status[pkt] == TX_DONE_STAT_SUCCESS) {
 				unsigned int ts2;
+				unsigned int ldelta = 0;
+				int ets_band;
 				int bts_vif = uvif->vif_index;
 
+				ets_band = get_band_chanctx(dev, uvif);
 				spin_lock(&tsf_lock);
 				dev->params->sync[bts_vif].status = 1;
 				memcpy(dev->params->sync[bts_vif].bssid,
@@ -832,9 +843,17 @@ int uccp420wlan_tx_free_buff_req(struct mac80211_dev *dev,
 					(tx_done->reserved + 8), 4);
 				ts2 = dev->params->sync[bts_vif].ts2;
 				dev->params->sync[bts_vif].atu = 0;
-				if (frc_to_atu)
+
+				if (IEEE80211_BAND_2GHZ == ets_band)
+					ldelta = BTS_AP_24GHZ_ETS;
+				else if (IEEE80211_BAND_5GHZ == ets_band)
+					ldelta = BTS_AP_5GHZ_ETS;
+
+				if (frc_to_atu) {
 					frc_to_atu(ts2,
 					&dev->params->sync[bts_vif].atu, 0);
+				dev->params->sync[bts_vif].atu += ldelta * 1000;
+				}
 				spin_unlock(&tsf_lock);
 			}
 
@@ -856,23 +875,41 @@ out:
 	return min(pkts_pend, max_tx_cmds);
 }
 
+
 #ifdef MULTI_CHAN_SUPPORT
 void uccp420wlan_proc_tx_discard_chsw(struct mac80211_dev *dev,
+				      int curr_chanctx_idx,
 				      struct umac_event_tx_done *tx_done)
 {
 	struct tx_config *tx = &dev->tx;
 	struct sk_buff_head *txq = NULL;
+	struct sk_buff_head tx_done_list;
 	int chanctx_idx = -1;
 	int pkt = 0;
+#ifdef notyet
+	int i = 0;
+#endif
 	unsigned long flags;
 	int txq_len = 0;
 	struct sk_buff *skb = NULL;
+	struct sk_buff *skb_first = NULL;
 	struct sk_buff *tmp = NULL;
 	int curr_bit = 0;
 	int pool_id = 0;
 	int queue = 0;
 	int ret = 0;
 	unsigned int desc_id = 0;
+	int peer_id = -1;
+	int ac = -1;
+	unsigned int *curr_retries = NULL;
+	unsigned int max_retries = 0;
+	struct ieee80211_tx_info tx_info_1st_mpdu;
+	struct ieee80211_hdr *mac_hdr = NULL;
+	bool retries_exceeded = false;
+	unsigned int *rate = NULL;
+	unsigned int *retries = NULL;
+
+	skb_queue_head_init(&tx_done_list);
 
 	spin_lock_irqsave(&tx->lock, flags);
 
@@ -880,7 +917,8 @@ void uccp420wlan_proc_tx_discard_chsw(struct mac80211_dev *dev,
 
 	/* We keep the frames which were not consumed by the FW in the
 	 * tx_pkt queue. These frames will then be requeued to the FW when this
-	 * channel context is scheduled again */
+	 * channel context is scheduled again
+	 */
 	chanctx_idx = tx->desc_chan_map[desc_id];
 
 	if (chanctx_idx == -1) {
@@ -896,8 +934,49 @@ void uccp420wlan_proc_tx_discard_chsw(struct mac80211_dev *dev,
 		goto out;
 	}
 
+	DEBUG_LOG("%s-UMACTX: %s: %d retries: %d rate: %d\n",
+		  dev->name,
+		  __func__,
+		  __LINE__,
+		  tx_done->retries_num[0],
+		  tx_done->rate[0]);
+
 	pkt = 0;
 
+	skb_first = skb_peek(txq);
+	curr_retries = &tx->pkt_info[chanctx_idx][desc_id].curr_retries;
+	max_retries = tx->pkt_info[chanctx_idx][desc_id].max_retries;
+	retries = tx->pkt_info[chanctx_idx][desc_id].retries;
+	rate = tx->pkt_info[chanctx_idx][desc_id].rate;
+	tx->pkt_info[chanctx_idx][desc_id].adjusted_rates = true;
+
+	if ((tx_done->retries_num[0] + *curr_retries) > max_retries) {
+		retries_exceeded = true;
+	} else {
+		*curr_retries += tx_done->retries_num[0];
+#ifdef notyet
+		/* Adjust the counters here */
+		for (i = 0; i < 4; i++) {
+			if (tx_done->rate[0] != rate[i])
+				retries[i] = 0;
+			else
+				retries[i] -= tx_done->retries_num[0];
+
+			DEBUG_LOG("%s-UMACTX: %s: %d %s %d == %d retries\n",
+				  dev->name,
+				  __func__,
+				  __LINE__,
+				  "adjusted indices are",
+				  i,
+				  retries[i]);
+		}
+#endif
+	}
+
+	memcpy(&tx_info_1st_mpdu,
+	       (struct ieee80211_tx_info *)IEEE80211_SKB_CB(skb_first),
+	       sizeof(struct ieee80211_tx_info));
+
 	skb_queue_walk_safe(txq, skb, tmp) {
 		if (!skb)
 			continue;
@@ -910,43 +989,138 @@ void uccp420wlan_proc_tx_discard_chsw(struct mac80211_dev *dev,
 		skb_push(skb,
 			 tx->pkt_info[chanctx_idx][desc_id].hdr_len);
 
+		mac_hdr = (struct ieee80211_hdr *)skb->data;
+
+		if (retries_exceeded) {
+			__skb_unlink(skb, txq);
+
+			if (!skb)
+				continue;
+
+			skb_queue_tail(&tx_done_list, skb);
+
+			DEBUG_LOG("%s-UMACTX: %s: %d %s\n",
+				  dev->name,
+				  __func__,
+				  __LINE__,
+				 "Freeing the skb MAX retries reached");
+		} else {
+			DEBUG_LOG("%s-UMACTX: %s: %d %s %s\n",
+				  dev->name,
+				  __func__,
+				  __LINE__,
+				  "Re-programming the skb when CTX is right",
+				  "with retry bit set");
+
+			mac_hdr->frame_control |=
+				cpu_to_le16(IEEE80211_FCTL_RETRY);
+		}
+
 		pkt++;
 	}
 
-	if (chanctx_idx != dev->curr_chanctx_idx) {
+	if (chanctx_idx != curr_chanctx_idx) {
 		/* First check if there is a packet in the txq of the current
-		 * chanctx that needs to be transmitted */
-		txq = &tx->pkt_info[dev->curr_chanctx_idx][desc_id].pkt;
+		 * chanctx that needs to be transmitted
+		 */
+		txq = &tx->pkt_info[curr_chanctx_idx][desc_id].pkt;
 		txq_len = skb_queue_len(txq);
-		queue = tx->pkt_info[dev->curr_chanctx_idx][desc_id].queue;
+		queue = tx->pkt_info[curr_chanctx_idx][desc_id].queue;
 
 		if (txq_len) {
 			spin_unlock_irqrestore(&tx->lock, flags);
 
 			/* TODO: Currently sending 0 since this param is not
-			   used as expected in the orig code for multiple
-			   frames etc Need to set this properly when the orig
-			   code logic is corrected */
+			 * used as expected in the orig code for multiple
+			 * frames etc Need to set this properly when the orig
+			 * code logic is corrected
+			 */
 			ret = __uccp420wlan_tx_frame(dev,
 						     queue,
 						     desc_id,
-						     0);
+						     curr_chanctx_idx,
+						     0,
+						     1);
 			if (ret < 0) {
 				/* TODO: Check if we need to clear the TX bitmap
-				   and desc_chan_map here */
+				 * and desc_chan_map here
+				 */
 				pr_err("%s: Queueing of TX frame to FW failed\n",
 				       __func__);
 			} else {
 				spin_lock_irqsave(&tx->lock, flags);
-				tx->desc_chan_map[desc_id] =
-						dev->curr_chanctx_idx;
+				tx->desc_chan_map[desc_id] = curr_chanctx_idx;
 				spin_unlock_irqrestore(&tx->lock, flags);
 			}
 
-			return;
+			goto tx_done;
+		} else {
+			/* Check pending queue */
+			/* Reserved token */
+			if (desc_id < (NUM_TX_DESCS_PER_AC * NUM_ACS)) {
+				queue = (desc_id % NUM_ACS);
+
+				peer_id = get_curr_peer_opp(dev,
+							    curr_chanctx_idx,
+							    queue);
+
+				if (peer_id == -1)
+					goto done;
+
+			/* Spare token */
+			} else {
+				for (ac = WLAN_AC_VO; ac >= 0; ac--) {
+					peer_id = get_curr_peer_opp(dev,
+							   curr_chanctx_idx,
+							   ac);
+
+					if (peer_id != -1) {
+						queue = ac;
+						break;
+					}
+				}
+
+				if (ac < 0)
+					goto done;
+			}
+
+			uccp420wlan_tx_proc_pend_frms(dev,
+						      queue,
+						      curr_chanctx_idx,
+						      peer_id,
+						      desc_id);
+
+			spin_unlock_irqrestore(&tx->lock, flags);
+
+			/* TODO: Currently sending 0 since this param is not
+			 * used as expected in the orig code for multiple
+			 * frames etc. Need to set this properly when the orig
+			 * code logic is corrected
+			 */
+			ret = __uccp420wlan_tx_frame(dev,
+						     queue,
+						     desc_id,
+						     curr_chanctx_idx,
+						     0,
+						     0);
+
+			if (ret < 0) {
+				/* SDK: Check if we need to clear the TX bitmap
+				 * and desc_chan_map here
+				 */
+				pr_err("%s: Queueing of TX frame to FW failed\n",
+				       __func__);
+			} else {
+				spin_lock_irqsave(&tx->lock, flags);
+				tx->desc_chan_map[desc_id] = curr_chanctx_idx;
+				spin_unlock_irqrestore(&tx->lock, flags);
+			}
+
+			goto tx_done;
 		}
 	}
 
+done:
 	curr_bit = (desc_id % TX_DESC_BUCKET_BOUND);
 	pool_id = (desc_id / TX_DESC_BUCKET_BOUND);
 
@@ -964,6 +1138,15 @@ void uccp420wlan_proc_tx_discard_chsw(struct mac80211_dev *dev,
 
 out:
 	spin_unlock_irqrestore(&tx->lock, flags);
+
+tx_done:
+	skb_queue_walk_safe(&tx_done_list, skb, tmp) {
+			tx_status(skb,
+				  tx_done,
+				  pkt,
+				  dev,
+				  tx_info_1st_mpdu);
+	}
 }
 #endif
 
@@ -996,9 +1179,7 @@ static void print_persec_stats(unsigned long data)
 void uccp420wlan_tx_init(struct mac80211_dev *dev)
 {
 	int i = 0;
-#if defined(UNIFORM_BW_SHARING) || defined(MULTI_CHAN_SUPPORT)
 	int j = 0;
-#endif
 	struct tx_config *tx = &dev->tx;
 
 	memset(&tx->buf_pool_bmp,
@@ -1009,12 +1190,8 @@ void uccp420wlan_tx_init(struct mac80211_dev *dev)
 	tx->next_spare_token_ac = WLAN_AC_BE;
 
 	for (i = 0; i < NUM_ACS; i++) {
-#ifdef UNIFORM_BW_SHARING
 		for (j = 0; j < MAX_PEND_Q_PER_AC; j++)
 			skb_queue_head_init(&tx->pending_pkt[j][i]);
-#else
-		skb_queue_head_init(&tx->pending_pkt[i]);
-#endif
 
 		tx->outstanding_tokens[i] = 0;
 	}
@@ -1030,7 +1207,6 @@ void uccp420wlan_tx_init(struct mac80211_dev *dev)
 #endif
 	}
 
-#ifdef UNIFORM_BW_SHARING
 	for (j = 0; j < NUM_ACS; j++)
 #ifdef MULTI_CHAN_SUPPORT
 		for (i = 0; i < MAX_CHANCTX; i++)
@@ -1038,7 +1214,6 @@ void uccp420wlan_tx_init(struct mac80211_dev *dev)
 #else
 		tx->curr_peer_opp[j] = 0;
 #endif
-#endif
 
 #ifdef PERF_PROFILING
 	init_timer(&tx->persec_timer);
@@ -1056,9 +1231,7 @@ void uccp420wlan_tx_init(struct mac80211_dev *dev)
 void uccp420wlan_tx_deinit(struct mac80211_dev *dev)
 {
 	int i = 0;
-#if defined(UNIFORM_BW_SHARING) || defined(MULTI_CHAN_SUPPORT)
 	int j = 0;
-#endif
 	unsigned long flags = 0;
 	struct tx_config *tx = &dev->tx;
 	struct sk_buff *skb;
@@ -1082,17 +1255,12 @@ void uccp420wlan_tx_deinit(struct mac80211_dev *dev)
 	}
 
 	for (i = 0; i < NUM_ACS; i++) {
-#ifdef UNIFORM_BW_SHARING
 		for (j = 0; j < MAX_PEND_Q_PER_AC; j++) {
 			while ((skb =
 				skb_dequeue(&tx->pending_pkt[j][i])) !=
 			       NULL)
 				dev_kfree_skb_any(skb);
 		}
-#else
-		while ((skb = skb_dequeue(&tx->pending_pkt[i])) != NULL)
-			dev_kfree_skb_any(skb);
-#endif
 	}
 
 	spin_unlock_irqrestore(&tx->lock, flags);
@@ -1104,17 +1272,24 @@ void uccp420wlan_tx_deinit(struct mac80211_dev *dev)
 int __uccp420wlan_tx_frame(struct mac80211_dev *dev,
 			   unsigned int queue,
 			   unsigned int token_id,
-			   unsigned int more_frames)
+#ifdef MULTI_CHAN_SUPPORT
+			   int curr_chanctx_idx,
+#endif
+			   unsigned int more_frames,
+			   bool retry)
 {
 	struct umac_event_tx_done tx_done;
 	struct sk_buff_head *txq = NULL;
 	int ret = 0;
 	int pkt = 0;
+
+	ret = uccp420wlan_prog_tx(queue,
+				  more_frames,
 #ifdef MULTI_CHAN_SUPPORT
-	int chan_id = 0;
+				  curr_chanctx_idx,
 #endif
-
-	ret = uccp420wlan_prog_tx(queue, more_frames, token_id);
+				  token_id,
+				  retry);
 
 	if (ret < 0) {
 		pr_err("%s-UMACTX: Unable to send frame, dropping ..%d\n",
@@ -1124,8 +1299,7 @@ int __uccp420wlan_tx_frame(struct mac80211_dev *dev,
 		tx_done.queue = queue;
 
 #ifdef MULTI_CHAN_SUPPORT
-		chan_id = dev->curr_chanctx_idx;
-		txq = &dev->tx.pkt_info[chan_id][token_id].pkt;
+		txq = &dev->tx.pkt_info[curr_chanctx_idx][token_id].pkt;
 #else
 		txq = &dev->tx.pkt_info[token_id].pkt;
 #endif
@@ -1135,7 +1309,11 @@ int __uccp420wlan_tx_frame(struct mac80211_dev *dev,
 			tx_done.rate[pkt] = 0;
 		}
 
-		uccp420wlan_tx_complete(&tx_done, dev);
+		uccp420wlan_tx_complete(&tx_done,
+#ifdef MULTI_CHAN_SUPPORT
+					curr_chanctx_idx,
+#endif
+					dev);
 	}
 
 	return ret;
@@ -1145,6 +1323,9 @@ int __uccp420wlan_tx_frame(struct mac80211_dev *dev,
 int uccp420wlan_tx_frame(struct sk_buff *skb,
 			 struct ieee80211_sta *sta,
 			 struct mac80211_dev *dev,
+#ifdef MULTI_CHAN_SUPPORT
+			 int curr_chanctx_idx,
+#endif
 			 bool bcast)
 {
 	unsigned int queue = 0;
@@ -1152,26 +1333,19 @@ int uccp420wlan_tx_frame(struct sk_buff *skb,
 	unsigned int more_frames = 0;
 	int ret = 0;
 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
-#if defined(UNIFORM_BW_SHARING) || defined(MULTI_CHAN_SUPPORT)
+	struct ieee80211_hdr *mac_hdr = NULL;
 	struct umac_vif *uvif = NULL;
-#endif
-#ifdef UNIFORM_BW_SHARING
 	struct umac_sta *usta = NULL;
 	int peer_id = -1;
-#endif
 
-#if defined(UNIFORM_BW_SHARING) || defined(MULTI_CHAN_SUPPORT)
 	uvif = (struct umac_vif *)(tx_info->control.vif->drv_priv);
-#endif
 
-#ifdef UNIFORM_BW_SHARING
 	if (sta) {
 		usta = (struct umac_sta *)sta->drv_priv;
 		peer_id = usta->index;
 	} else {
 		peer_id = MAX_PEERS + uvif->vif_index;
 	}
-#endif
 
 	if (bcast == false) {
 		queue = tx_queue_map(skb->queue_mapping);
@@ -1193,18 +1367,24 @@ int uccp420wlan_tx_frame(struct sk_buff *skb,
 		atomic_inc(&dev->roc_params.roc_mgmt_tx_count);
 	}
 
-	DEBUG_LOG("%s-UMACTX:%s:%d Waiting for Allocation:queue: %d qmap: %d\n",
-		dev->name,
-		__func__, __LINE__, queue, skb->queue_mapping);
+	mac_hdr = (struct ieee80211_hdr *)(skb->data);
+
+	DEBUG_LOG("%s-UMACTX:%s:%d %s:queue: %d qmap: %d is_bcn: %d\n",
+		  dev->name,
+		  __func__,
+		  __LINE__,
+		  "Waiting for Allocation",
+		  queue,
+		  skb->queue_mapping,
+		  ieee80211_is_beacon(mac_hdr->frame_control));
 
 	token_id = uccp420wlan_tx_alloc_buff_req(dev,
 						 queue,
 #ifdef MULTI_CHAN_SUPPORT
 						 uvif,
+						 curr_chanctx_idx,
 #endif
-#ifdef UNIFORM_BW_SHARING
 						 peer_id,
-#endif
 						 skb);
 
 	/* The frame was unable to find a reserved token */
@@ -1217,7 +1397,11 @@ int uccp420wlan_tx_frame(struct sk_buff *skb,
 	ret = __uccp420wlan_tx_frame(dev,
 				     queue,
 				     token_id,
-				     more_frames);
+#ifdef MULTI_CHAN_SUPPORT
+				     curr_chanctx_idx,
+#endif
+				     more_frames,
+				     0);
 
 
 	return NETDEV_TX_OK;
@@ -1252,26 +1436,24 @@ void uccp420wlan_proc_tx_complete(struct umac_event_tx_done *tx_done,
 }
 
 void uccp420wlan_tx_complete(struct umac_event_tx_done *tx_done,
+#ifdef MULTI_CHAN_SUPPORT
+			     int curr_chanctx_idx,
+#endif
 			     void *context)
 {
 	struct mac80211_dev *dev = (struct mac80211_dev *)context;
-	unsigned int  more_frames;
+	unsigned int more_frames = 0;
 	int vif_index = 0, vif_index_bitmap = 0, ret = 0;
 	unsigned int pkts_pending = 0;
 	unsigned char queue = 0;
 	struct umac_event_noa noa_event;
 	int token_id = 0;
 	int qlen = 0;
-#ifdef MULTI_CHAN_SUPPORT
-	int chanctx_idx = 0;
-
-	chanctx_idx = dev->curr_chanctx_idx;
-#endif
 
 	token_id = tx_done->descriptor_id;
 
 #ifdef MULTI_CHAN_SUPPORT
-	qlen = skb_queue_len(&dev->tx.pkt_info[chanctx_idx][token_id].pkt);
+	qlen = skb_queue_len(&dev->tx.pkt_info[curr_chanctx_idx][token_id].pkt);
 #else
 	qlen = skb_queue_len(&dev->tx.pkt_info[token_id].pkt);
 #endif
@@ -1285,13 +1467,18 @@ void uccp420wlan_tx_complete(struct umac_event_tx_done *tx_done,
 
 #ifdef MULTI_CHAN_SUPPORT
 	if (tx_done->frm_status[0] == TX_DONE_STAT_DISCARD_CHSW) {
-		uccp420wlan_proc_tx_discard_chsw(dev, tx_done);
+		uccp420wlan_proc_tx_discard_chsw(dev,
+						 curr_chanctx_idx,
+						 tx_done);
 		return;
 	}
 #endif
 	pkts_pending = uccp420wlan_tx_free_buff_req(dev,
 						    tx_done,
 						    &queue,
+#ifdef MULTI_CHAN_SUPPORT
+						    curr_chanctx_idx,
+#endif
 						    &vif_index_bitmap);
 
 	if (pkts_pending) {
@@ -1304,14 +1491,18 @@ void uccp420wlan_tx_complete(struct umac_event_tx_done *tx_done,
 #endif
 		more_frames = 0;
 
-			DEBUG_LOG("%s-UMACTX:%s:%d Transfer Pending Frames:\n",
-			       dev->name,
-			       __func__, __LINE__);
+		DEBUG_LOG("%s-UMACTX:%s:%d Transfer Pending Frames:\n",
+			  dev->name,
+			  __func__, __LINE__);
 
 		ret = __uccp420wlan_tx_frame(dev,
 					     queue,
 					     token_id,
-					     more_frames);
+#ifdef MULTI_CHAN_SUPPORT
+					     curr_chanctx_idx,
+#endif
+					     more_frames,
+					     0);
 
 	} else {
 		DEBUG_LOG("%s-UMACTX:No Pending Packets\n", dev->name);
diff --git a/drivers/net/wireless/uccp420wlan/src/umac_if.c b/drivers/net/wireless/uccp420wlan/src/umac_if.c
index c9c18c1..f37aa30 100644
--- a/drivers/net/wireless/uccp420wlan/src/umac_if.c
+++ b/drivers/net/wireless/uccp420wlan/src/umac_if.c
@@ -139,6 +139,8 @@ static void update_mcs_packet_stat(int mcs_rate_num,
 
 static void get_rate(struct sk_buff *skb,
 		     struct cmd_tx_ctrl *txcmd,
+		     struct tx_pkt_info *pkt_info,
+		     bool retry,
 		     struct mac80211_dev *dev)
 {
 	struct ieee80211_rate *rate;
@@ -461,7 +463,28 @@ static void get_rate(struct sk_buff *skb,
 			!(txcmd->rate_flags[index] &
 			  ENABLE_CHNL_WIDTH_80MHZ))
 				/* Downgrade to VHT-MCS8-Nss-1 */
-				txcmd->rate[index] = 0x88;
+			txcmd->rate[index] = 0x88;
+
+		/*First Time*/
+#ifdef notyet
+		if (!retry) {
+#endif
+			if (!index)
+				pkt_info->max_retries = 0;
+			pkt_info->max_retries +=
+				txcmd->rate_retries[index];
+#ifdef notyet
+			pkt_info->retries[index] =
+				txcmd->rate_retries[index];
+			DEBUG_LOG("%s-UMACTX : Using MINSTREL rates\n",
+				  dev->name);
+		} else {
+			txcmd->rate_retries[index] =
+				pkt_info->retries[index];
+			DEBUG_LOG("%s-UMACTX : Using Adjusted rates\n",
+				  dev->name);
+		}
+#endif
 
 		txcmd->num_rates++;
 	}
@@ -814,7 +837,7 @@ int uccp420wlan_prog_vht_bform(unsigned int vht_beamform_status,
 }
 
 
-int uccp420wlan_prog_roc(unsigned int roc_status,
+int uccp420wlan_prog_roc(unsigned int roc_ctrl,
 			 unsigned int roc_channel,
 			 unsigned int roc_duration)
 {
@@ -822,7 +845,7 @@ int uccp420wlan_prog_roc(unsigned int roc_status,
 
 	memset(&cmd_roc, 0, sizeof(struct cmd_roc));
 
-	cmd_roc.roc_status	= roc_status;
+	cmd_roc.roc_ctrl	= roc_ctrl;
 	cmd_roc.roc_channel	= roc_channel;
 	cmd_roc.roc_duration	= roc_duration;
 
@@ -1170,8 +1193,8 @@ int uccp420wlan_scan_abort(int index)
 
 
 int uccp420wlan_prog_channel(unsigned int prim_ch,
-			     unsigned int ch_no1,
-			     unsigned int ch_no2,
+			     unsigned int center_freq1,
+			     unsigned int center_freq2,
 			     unsigned int ch_width,
 #ifdef MULTI_CHAN_SUPPORT
 			     unsigned int vif_index,
@@ -1179,8 +1202,72 @@ int uccp420wlan_prog_channel(unsigned int prim_ch,
 			     unsigned int freq_band)
 {
 	struct cmd_channel channel;
+	struct lmac_if_data *p;
+	struct mac80211_dev *dev;
+	int is_vht_bw80_sec_40minus;
+	int is_vht_bw80_sec_40plus;
+	int is_vht_bw80;
+	int ch_no1, ch_no2;
+	unsigned int cf_offset = center_freq1;
 
 	memset(&channel, 0, sizeof(struct cmd_channel));
+
+	rcu_read_lock();
+	p = (struct lmac_if_data *)(rcu_dereference(lmac_if));
+
+	if (!p) {
+		WARN_ON(1);
+		rcu_read_unlock();
+		return -1;
+		}
+	dev = p->context;
+	if (dev->params->production_test == 1) {
+			if ((dev->params->prod_mode_chnl_bw_40_mhz == 1) &&
+				(dev->params->sec_ch_offset_40_minus == 1)) {
+				/*  NL80211_CHAN_HT40MINUS */
+				ch_width = 2;
+				cf_offset -= 10;
+			} else if (dev->params->prod_mode_chnl_bw_40_mhz == 1) {
+				/* NL80211_CHAN_HT40PLUS */
+				ch_width = 2;
+				cf_offset += 10;
+			}
+
+			is_vht_bw80 = vht_support &&
+				(dev->params->prod_mode_chnl_bw_80_mhz == 1);
+
+			is_vht_bw80_sec_40minus = is_vht_bw80 &&
+				(dev->params->sec_ch_offset_40_minus == 1);
+
+			is_vht_bw80_sec_40plus = is_vht_bw80 &&
+				(dev->params->sec_ch_offset_40_plus == 1);
+
+			if (is_vht_bw80)
+				ch_width = 3;
+
+			if (is_vht_bw80_sec_40minus &&
+			    (dev->params->sec_40_ch_offset_80_minus == 1))
+				cf_offset -= 30;
+			else if (is_vht_bw80_sec_40minus &&
+				 (dev->params->sec_40_ch_offset_80_plus == 1))
+				cf_offset += 10;
+			else if (is_vht_bw80_sec_40minus)/* default */
+				cf_offset -= 30;
+
+			if (is_vht_bw80_sec_40plus &&
+			    (dev->params->sec_40_ch_offset_80_minus == 1))
+				cf_offset -= 10;
+			else if (is_vht_bw80_sec_40plus &&
+				 (dev->params->sec_40_ch_offset_80_plus == 1))
+				cf_offset += 30;
+			else if (is_vht_bw80_sec_40plus)/* default */
+				cf_offset -= 10;
+
+
+	}
+	ch_no1 = ieee80211_frequency_to_channel(cf_offset);
+	ch_no2 = 0;
+
 	channel.primary_ch_number = prim_ch;
 	channel.channel_number1 = ch_no1;
 	channel.channel_number2 = ch_no2;
@@ -1208,6 +1295,12 @@ int uccp420wlan_prog_channel(unsigned int prim_ch,
 #ifdef MULTI_CHAN_SUPPORT
 	channel.vif_index = vif_index;
 #endif
+	dev->cur_chan.center_freq1 = cf_offset;
+	dev->cur_chan.center_freq2 = ch_no2;
+	dev->cur_chan.pri_chnl_num = prim_ch;
+	dev->cur_chan.ch_width  = ch_width;
+	dev->cur_chan.freq_band = freq_band;
+	dev->chan_prog_done = 0;
 
 	return uccp420wlan_send_cmd((unsigned char *) &channel,
 				    sizeof(struct cmd_channel),
@@ -1289,7 +1382,11 @@ int uccp420wlan_prog_ps_state(int index,
 
 int uccp420wlan_prog_tx(unsigned int queue,
 			unsigned int more_frms,
-			unsigned int descriptor_id)
+#ifdef MULTI_CHAN_SUPPORT
+			int curr_chanctx_idx,
+#endif
+			unsigned int descriptor_id,
+			bool retry)
 {
 	struct cmd_tx_ctrl tx_cmd;
 	struct sk_buff *nbuf, *nbuf_start;
@@ -1306,7 +1403,7 @@ int uccp420wlan_prog_tx(unsigned int queue,
 	__u16 fc;
 	unsigned long irq_flags, tx_irq_flags;
 #ifdef MULTI_CHAN_SUPPORT
-	int chan_id = 0;
+	struct tx_pkt_info *pkt_info = NULL;
 #endif
 
 	memset(&tx_cmd, 0, sizeof(struct cmd_tx_ctrl));
@@ -1323,9 +1420,11 @@ int uccp420wlan_prog_tx(unsigned int queue,
 	dev = p->context;
 	spin_lock_irqsave(&dev->tx.lock, tx_irq_flags);
 #ifdef MULTI_CHAN_SUPPORT
-	txq = &dev->tx.pkt_info[dev->curr_chanctx_idx][descriptor_id].pkt;
+	txq = &dev->tx.pkt_info[curr_chanctx_idx][descriptor_id].pkt;
+	pkt_info = &dev->tx.pkt_info[curr_chanctx_idx][descriptor_id];
 #else
 	txq = &dev->tx.pkt_info[descriptor_id].pkt;
+	pkt_info = &dev->tx.pkt_info[descriptor_id];
 #endif
 	skb_first = skb_peek(txq);
 
@@ -1406,8 +1505,12 @@ int uccp420wlan_prog_tx(unsigned int queue,
 		return -20;
 	}
 
-	 /* Get the rate for first packet as all packets have same rate */
-	get_rate(skb_first, &tx_cmd, dev);
+	/* Get the rate for first packet as all packets have same rate */
+	get_rate(skb_first,
+		 &tx_cmd,
+		 pkt_info,
+		 retry,
+		 dev);
 
 	data = skb_put(nbuf, sizeof(struct cmd_tx_ctrl));
 	memset(data, 0, sizeof(struct cmd_tx_ctrl));
@@ -1430,6 +1533,14 @@ int uccp420wlan_prog_tx(unsigned int queue,
 		     tx_cmd.rate[2],
 		     tx_cmd.rate[3]);
 
+	DEBUG_LOG("%s-UMACTX: Retries   = %d, %d, %d, %d, %d\n",
+		  dev->name,
+		  pkt_info->max_retries,
+		  tx_cmd.rate_retries[0],
+		  tx_cmd.rate_retries[1],
+		  tx_cmd.rate_retries[2],
+		  tx_cmd.rate_retries[3]);
+
 	skb_queue_walk_safe(txq, skb, tmp) {
 		if (!skb || (pkt > tx_cmd.num_frames_per_desc))
 			break;
@@ -1439,7 +1550,8 @@ int uccp420wlan_prog_tx(unsigned int queue,
 		/* Only for Non-Qos and MGMT frames, for Qos-Data
 		 * mac80211 handles the sequence no generation
 		 */
-		if (tx_info_first->flags &
+		if (!retry &&
+		    tx_info_first->flags &
 		    IEEE80211_TX_CTL_ASSIGN_SEQ) {
 			if (tx_info_first->flags &
 			    IEEE80211_TX_CTL_FIRST_FRAGMENT) {
@@ -1452,9 +1564,9 @@ int uccp420wlan_prog_tx(unsigned int queue,
 
 		/* Need it for tx_status later */
 #ifdef MULTI_CHAN_SUPPORT
-		dev->tx.pkt_info[dev->curr_chanctx_idx][descriptor_id].hdr_len =
+		dev->tx.pkt_info[curr_chanctx_idx][descriptor_id].hdr_len =
 			hdrlen;
-		dev->tx.pkt_info[dev->curr_chanctx_idx][descriptor_id].queue =
+		dev->tx.pkt_info[curr_chanctx_idx][descriptor_id].queue =
 			queue;
 #else
 		dev->tx.pkt_info[descriptor_id].hdr_len = hdrlen;
@@ -1492,10 +1604,10 @@ int uccp420wlan_prog_tx(unsigned int queue,
 #endif
 
 		/* SDK: Check if we can use the same txq initialized before in
-		 * the function here */
+		 * the function here
+		 */
 #ifdef MULTI_CHAN_SUPPORT
-		chan_id = dev->curr_chanctx_idx;
-		txq = &dev->tx.pkt_info[chan_id][descriptor_id].pkt;
+		txq = &dev->tx.pkt_info[curr_chanctx_idx][descriptor_id].pkt;
 #else
 		txq = &dev->tx.pkt_info[descriptor_id].pkt;
 #endif
@@ -1974,8 +2086,8 @@ int uccp420wlan_prog_econ_ps_state(int if_index,
 #endif
 
 
-int uccp420wlan_msg_handler (void *nbuff,
-			     unsigned char sender_id)
+int uccp420wlan_msg_handler(void *nbuff,
+			    unsigned char sender_id)
 {
 	unsigned int event;
 	unsigned char *buff;
@@ -1985,6 +2097,9 @@ int uccp420wlan_msg_handler (void *nbuff,
 	struct sk_buff *pending_cmd;
 	unsigned long irq_flags;
 	struct mac80211_dev *dev;
+#ifdef MULTI_CHAN_SUPPORT
+	int curr_chanctx_idx = -1;
+#endif
 
 	rcu_read_lock();
 
@@ -2070,7 +2185,15 @@ int uccp420wlan_msg_handler (void *nbuff,
 			 */
 			dev->stats->tx_done_recv_count++;
 
+#ifdef MULTI_CHAN_SUPPORT
+			spin_lock(&dev->chanctx_lock);
+			curr_chanctx_idx = dev->curr_chanctx_idx;
+			spin_unlock(&dev->chanctx_lock);
+#endif
 			uccp420wlan_tx_complete((void *)buff,
+#ifdef MULTI_CHAN_SUPPORT
+						curr_chanctx_idx,
+#endif
 						p->context);
 		}
 
@@ -2162,7 +2285,8 @@ int uccp420wlan_msg_handler (void *nbuff,
 		uccp420wlan_rf_calib_data(rf_data, p->context);
 #ifdef MULTI_CHAN_SUPPORT
 	/* SDK: Need to see if this will work in tasklet context (due to
-	 * scheduling latencies) */
+	 * scheduling latencies)
+	 */
 	} else if (event == UMAC_EVENT_CHAN_SWITCH) {
 		uccp420wlan_proc_ch_sw_event((void *)buff,
 					     p->context);
-- 
1.9.1

